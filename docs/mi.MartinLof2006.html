<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>P. Martin-Löf (2006) 100 years of Zermelo’s axiom of choice: What was the problem with it? — Mechanised Intuitionist</title>
  <link rel="stylesheet" href="mi-common.css">
  <link rel="stylesheet" href="mi-layout.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
</head>
<body>
<nav id="head">
<p><a href="mi.index.html">Mechanised Intuitionist</a></p>
</nav>
<main>
<header id="title-block-header">
<h1 class="title">100 years of Zermelo’s<br>axiom of choice:<br>What was the problem with it?</h1>
<p class="author">Per Martin-Löf</p>
<p class="year">2006</p>
</header>
<pre class="Agda"><a id="457" class="Comment">-- Mechanised by Miëtek Bak</a>

<a id="486" class="Keyword">module</a> <a id="493" href="mi.MartinLof2006.html" class="Module">mi.MartinLof2006</a> <a id="510" class="Keyword">where</a>

<a id="517" class="Keyword">open</a> <a id="522" class="Keyword">import</a> <a id="529" href="Data.Product.html" class="Module">Data.Product</a> <a id="542" class="Keyword">using</a> <a id="548" class="Symbol">(</a><a id="549" href="Agda.Builtin.Sigma.html#139" class="Record">Σ</a> <a id="551" class="Symbol">;</a> <a id="553" href="Data.Product.html#911" class="Function">Σ-syntax</a> <a id="562" class="Symbol">;</a> <a id="564" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="568" class="Symbol">;</a> <a id="570" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="576" class="Symbol">;</a> <a id="578" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="584" class="Symbol">;</a> <a id="586" href="Data.Product.html#1162" class="Function Operator">_×_</a><a id="589" class="Symbol">)</a>
<a id="591" class="Keyword">open</a> <a id="596" class="Keyword">import</a> <a id="603" href="Function.html" class="Module">Function</a> <a id="612" class="Keyword">using</a> <a id="618" class="Symbol">(</a><a id="619" href="Function.html#1099" class="Function Operator">_∘_</a><a id="622" class="Symbol">)</a>
<a id="624" class="Keyword">open</a> <a id="629" class="Keyword">import</a> <a id="636" href="Level.html" class="Module">Level</a> <a id="642" class="Keyword">using</a> <a id="648" class="Symbol">(</a><a id="649" href="Agda.Primitive.html#657" class="Primitive Operator">_⊔_</a><a id="652" class="Symbol">)</a>
<a id="654" class="Keyword">open</a> <a id="659" class="Keyword">import</a> <a id="666" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="682" class="Keyword">using</a> <a id="688" class="Symbol">(</a><a id="689" href="Relation.Binary.html#1970" class="Record">Setoid</a><a id="695" class="Symbol">)</a>
<a id="697" class="Keyword">open</a> <a id="702" class="Keyword">import</a> <a id="709" href="Relation.Unary.html" class="Module">Relation.Unary</a> <a id="724" class="Keyword">using</a> <a id="730" class="Symbol">(</a><a id="731" href="Relation.Unary.html#4268" class="Function Operator">_∩_</a><a id="734" class="Symbol">)</a>

<a id="_↔_"></a><a id="737" href="mi.MartinLof2006.html#737" class="Function Operator">_↔_</a> <a id="741" class="Symbol">:</a> <a id="743" class="Symbol">∀</a> <a id="745" class="Symbol">{</a><a id="746" href="mi.MartinLof2006.html#746" class="Bound">𝒶</a> <a id="748" href="mi.MartinLof2006.html#748" class="Bound">𝒷</a><a id="749" class="Symbol">}</a> <a id="751" class="Symbol">(</a><a id="752" href="mi.MartinLof2006.html#752" class="Bound">A</a> <a id="754" class="Symbol">:</a> <a id="756" class="PrimitiveType">Set</a> <a id="760" href="mi.MartinLof2006.html#746" class="Bound">𝒶</a><a id="761" class="Symbol">)</a> <a id="763" class="Symbol">(</a><a id="764" href="mi.MartinLof2006.html#764" class="Bound">B</a> <a id="766" class="Symbol">:</a> <a id="768" class="PrimitiveType">Set</a> <a id="772" href="mi.MartinLof2006.html#748" class="Bound">𝒷</a><a id="773" class="Symbol">)</a> <a id="775" class="Symbol">→</a> <a id="777" class="PrimitiveType">Set</a> <a id="781" class="Symbol">_</a>
<a id="783" href="mi.MartinLof2006.html#783" class="Bound">A</a> <a id="785" href="mi.MartinLof2006.html#737" class="Function Operator">↔</a> <a id="787" href="mi.MartinLof2006.html#787" class="Bound">B</a> <a id="789" class="Symbol">=</a> <a id="791" class="Symbol">(</a><a id="792" href="mi.MartinLof2006.html#783" class="Bound">A</a> <a id="794" class="Symbol">→</a> <a id="796" href="mi.MartinLof2006.html#787" class="Bound">B</a><a id="797" class="Symbol">)</a> <a id="799" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="801" class="Symbol">(</a><a id="802" href="mi.MartinLof2006.html#787" class="Bound">B</a> <a id="804" class="Symbol">→</a> <a id="806" href="mi.MartinLof2006.html#783" class="Bound">A</a><a id="807" class="Symbol">)</a>

<a id="Σ!-syntax"></a><a id="810" href="mi.MartinLof2006.html#810" class="Function">Σ!-syntax</a> <a id="820" class="Symbol">:</a> <a id="822" class="Symbol">∀</a> <a id="824" class="Symbol">{</a><a id="825" href="mi.MartinLof2006.html#825" class="Bound">𝒶</a> <a id="827" href="mi.MartinLof2006.html#827" class="Bound">𝒶ₑ</a> <a id="830" href="mi.MartinLof2006.html#830" class="Bound">𝒷</a><a id="831" class="Symbol">}</a> <a id="833" class="Symbol">(</a><a id="834" href="mi.MartinLof2006.html#834" class="Bound">A</a> <a id="836" class="Symbol">:</a> <a id="838" class="PrimitiveType">Set</a> <a id="842" href="mi.MartinLof2006.html#825" class="Bound">𝒶</a><a id="843" class="Symbol">)</a> <a id="845" class="Symbol">(</a><a id="846" href="mi.MartinLof2006.html#846" class="Bound Operator">_≈_</a> <a id="850" class="Symbol">:</a> <a id="852" href="mi.MartinLof2006.html#834" class="Bound">A</a> <a id="854" class="Symbol">→</a> <a id="856" href="mi.MartinLof2006.html#834" class="Bound">A</a> <a id="858" class="Symbol">→</a> <a id="860" class="PrimitiveType">Set</a> <a id="864" href="mi.MartinLof2006.html#827" class="Bound">𝒶ₑ</a><a id="866" class="Symbol">)</a> <a id="868" class="Symbol">(</a><a id="869" href="mi.MartinLof2006.html#869" class="Bound">B</a> <a id="871" class="Symbol">:</a> <a id="873" href="mi.MartinLof2006.html#834" class="Bound">A</a> <a id="875" class="Symbol">→</a> <a id="877" class="PrimitiveType">Set</a> <a id="881" href="mi.MartinLof2006.html#830" class="Bound">𝒷</a><a id="882" class="Symbol">)</a> <a id="884" class="Symbol">→</a> <a id="886" class="PrimitiveType">Set</a> <a id="890" class="Symbol">_</a>
<a id="892" href="mi.MartinLof2006.html#810" class="Function">Σ!-syntax</a> <a id="902" href="mi.MartinLof2006.html#902" class="Bound">A</a> <a id="904" href="mi.MartinLof2006.html#904" class="Bound Operator">_≈_</a> <a id="908" href="mi.MartinLof2006.html#908" class="Bound">B</a> <a id="910" class="Symbol">=</a> <a id="912" href="Data.Product.html#911" class="Function">Σ[</a> <a id="915" href="mi.MartinLof2006.html#915" class="Bound">x</a> <a id="917" href="Data.Product.html#911" class="Function">∈</a> <a id="919" href="mi.MartinLof2006.html#902" class="Bound">A</a> <a id="921" href="Data.Product.html#911" class="Function">]</a> <a id="923" href="mi.MartinLof2006.html#908" class="Bound">B</a> <a id="925" href="mi.MartinLof2006.html#915" class="Bound">x</a> <a id="927" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="929" class="Symbol">∀</a> <a id="931" class="Symbol">{</a><a id="932" href="mi.MartinLof2006.html#932" class="Bound">y</a><a id="933" class="Symbol">}</a> <a id="935" class="Symbol">→</a> <a id="937" href="mi.MartinLof2006.html#908" class="Bound">B</a> <a id="939" href="mi.MartinLof2006.html#932" class="Bound">y</a> <a id="941" class="Symbol">→</a> <a id="943" href="mi.MartinLof2006.html#915" class="Bound">x</a> <a id="945" href="mi.MartinLof2006.html#904" class="Bound Operator">≈</a> <a id="947" href="mi.MartinLof2006.html#932" class="Bound">y</a>

<a id="950" class="Keyword">infix</a> <a id="956" class="Number">2</a> <a id="958" href="mi.MartinLof2006.html#810" class="Function">Σ!-syntax</a>
<a id="968" class="Keyword">syntax</a> <a id="975" href="mi.MartinLof2006.html#810" class="Function">Σ!-syntax</a> <a id="985" class="Bound">A</a> <a id="987" class="Bound">_≈_</a> <a id="991" class="Symbol">(λ</a> <a id="994" class="Bound">x</a> <a id="996" class="Symbol">→</a> <a id="998" class="Bound">B</a><a id="999" class="Symbol">)</a> <a id="1001" class="Symbol">=</a> <a id="1003" class="Function">Σ![</a> <a id="1007" class="Bound">x</a> <a id="1009" class="Function">∈</a> <a id="1011" class="Bound">A</a> <a id="1013" class="Function">/</a> <a id="1015" class="Bound">_≈_</a> <a id="1019" class="Function">]</a> <a id="1021" class="Bound">B</a>
</pre>
<p>Cantor conceived set theory in a sequence of six papers published in the <em><span lang="de">Mathematische Annalen</span></em> during the five year period 1879–1884. In the fifth of these papers, published in 1883,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> he stated as a law of thought (<em><span lang="de">Denkgesetz</span></em>) that every set can be well-ordered or, more precisely, that it is always possible to bring any well-defined set into the form of a well-ordered set. Now to call it a law of thought was implicitly to claim self-evidence for it, but he must have given up that claim at some point, because in the 1890s he made an unsuccessful attempt at demonstrating the well-ordering principle.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>The first to succeed in doing so was Zermelo,<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> although, as a prerequisite of the demonstration, he had to introduce a new principle, which came to be called the principle of choice (<em><span lang="de">Prinzip der Auswahl</span></em>) respectively the axiom of choice (<em><span lang="de">Axiom der Auswahl</span></em>) in his two papers from 1908.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> His first paper on the subject, published in 1904, consists of merely three pages, excerpted by Hilbert from a letter which he had received from Zermelo. The letter is dated 24 September 1904, and the excerpt begins by saying that the demonstration came out of discussions with Erhard Schmidt during the preceding week, which means that we can safely date the appearance of the axiom of choice and the demonstration of the well-ordering theorem to September 1904.</p>
<p>Brief as it was, Zermelo’s paper gave rise to what is presumably the most lively discussion among mathematicians on the validity, or acceptability, of a mathematical axiom that has ever taken place. Within a couple of years, written contributions to this discussion were published by Felix Bernstein, Schoenflies, Hamel, Hessenberg and Hausdorff in Germany, Baire, Borel, Hadamard, Lebesgue, Richard and Poincaré in France, Hobson, Hardy, Jourdain and Russell in England, Julius König in Hungary, Peano in Italy and Brouwer in the Netherlands.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> Zermelo responded to those of these contributions that were critical, which was a majority, in a second paper from 1908. This second paper also contains a new proof of the well-ordering theorem, less intuitive or less perspicuous, it has to be admitted, than the original proof, as well as a new formulation of the axiom of choice, a formulation which will play a crucial role in the following considerations.</p>
<p>Despite the strength of the initial opposition against it, Zermelo’s axiom of choice gradually came to be accepted, mainly because it was needed at an early stage in the development of several branches of mathematics, not only set theory, but also topology, algebra and functional analysis, for example. Towards the end of the thirties, it had become firmly established and was made part of the standard mathematical curriculum in the form of Zorn’s lemma.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>The intuitionists, on the other hand, rejected the axiom of choice from the very beginning. Baire, Borel and Lebesgue were all critical of it in their contributions to the correspondence, which was published under the title <em><span lang="fr">Cinq lettres sur la théorie des ensembles</span></em> in 1905.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> Brouwer’s thesis from 1907 contains a section on the well-ordering principle in which it is treated in a dismissive fashion (“of course there is no motivation for this at all”) and in which, following Borel,<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> he belittles Zermelo’s proof of it from the axiom of choice.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> No further discussion of the axiom of choice seems to be found in either Brouwer’s or Heyting’s writings. Presumably, it was regarded by them as a prime example of a nonconstructive principle.</p>
<p>It therefore came as a surprise when, as late as in 1967, Bishop stated,</p>
<blockquote>
<p>A choice function exists in constructive mathematics, because a choice is <em>implied by the very meaning of existence</em>,<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
</blockquote>
<div class="align-bottom">
<p>although, in the terminology that he himself introduced in the subsequent chapter, he ought to have said “choice operation” rather than “choice function”. What he had in mind was clearly that the truth of</p>
<p><span class="math display">(∀i : I)(∃x : S)A(i, x) → (∃f : I → S)(∀i : I)A(i, f(i))</span></p>
<pre class="Agda"><a id="5146" class="Comment">-- (intensional, constructive, type-theoretic) axiom of choice</a>
<a id="5209" class="Keyword">module</a> <a id="5216" href="mi.MartinLof2006.html#5216" class="Module">_</a> <a id="5218" class="Symbol">{</a><a id="5219" href="mi.MartinLof2006.html#5219" class="Bound">𝒾</a> <a id="5221" href="mi.MartinLof2006.html#5221" class="Bound">𝓈</a> <a id="5223" href="mi.MartinLof2006.html#5223" class="Bound">𝒶</a><a id="5224" class="Symbol">}</a> <a id="5226" class="Symbol">{</a><a id="5227" href="mi.MartinLof2006.html#5227" class="Bound">I</a> <a id="5229" class="Symbol">:</a> <a id="5231" class="PrimitiveType">Set</a> <a id="5235" href="mi.MartinLof2006.html#5219" class="Bound">𝒾</a><a id="5236" class="Symbol">}</a> <a id="5238" class="Symbol">{</a><a id="5239" href="mi.MartinLof2006.html#5239" class="Bound">S</a> <a id="5241" class="Symbol">:</a> <a id="5243" class="PrimitiveType">Set</a> <a id="5247" href="mi.MartinLof2006.html#5221" class="Bound">𝓈</a><a id="5248" class="Symbol">}</a> <a id="5250" class="Symbol">{</a><a id="5251" href="mi.MartinLof2006.html#5251" class="Bound">A</a> <a id="5253" class="Symbol">:</a> <a id="5255" href="mi.MartinLof2006.html#5227" class="Bound">I</a> <a id="5257" class="Symbol">→</a> <a id="5259" href="mi.MartinLof2006.html#5239" class="Bound">S</a> <a id="5261" class="Symbol">→</a> <a id="5263" class="PrimitiveType">Set</a> <a id="5267" href="mi.MartinLof2006.html#5223" class="Bound">𝒶</a><a id="5268" class="Symbol">}</a> <a id="5270" class="Keyword">where</a>
  <a id="5278" href="mi.MartinLof2006.html#5278" class="Function">ac</a> <a id="5281" class="Symbol">:</a> <a id="5283" class="Symbol">(∀</a> <a id="5286" href="mi.MartinLof2006.html#5286" class="Bound">i</a> <a id="5288" class="Symbol">→</a> <a id="5290" href="Data.Product.html#911" class="Function">Σ[</a> <a id="5293" href="mi.MartinLof2006.html#5293" class="Bound">x</a> <a id="5295" href="Data.Product.html#911" class="Function">∈</a> <a id="5297" href="mi.MartinLof2006.html#5239" class="Bound">S</a> <a id="5299" href="Data.Product.html#911" class="Function">]</a> <a id="5301" href="mi.MartinLof2006.html#5251" class="Bound">A</a> <a id="5303" href="mi.MartinLof2006.html#5286" class="Bound">i</a> <a id="5305" href="mi.MartinLof2006.html#5293" class="Bound">x</a><a id="5306" class="Symbol">)</a> <a id="5308" class="Symbol">→</a> <a id="5310" href="Data.Product.html#911" class="Function">Σ[</a> <a id="5313" href="mi.MartinLof2006.html#5313" class="Bound">f</a> <a id="5315" href="Data.Product.html#911" class="Function">∈</a> <a id="5317" class="Symbol">(</a><a id="5318" href="mi.MartinLof2006.html#5227" class="Bound">I</a> <a id="5320" class="Symbol">→</a> <a id="5322" href="mi.MartinLof2006.html#5239" class="Bound">S</a><a id="5323" class="Symbol">)</a> <a id="5325" href="Data.Product.html#911" class="Function">]</a> <a id="5327" class="Symbol">∀</a> <a id="5329" href="mi.MartinLof2006.html#5329" class="Bound">i</a> <a id="5331" class="Symbol">→</a> <a id="5333" href="mi.MartinLof2006.html#5251" class="Bound">A</a> <a id="5335" href="mi.MartinLof2006.html#5329" class="Bound">i</a> <a id="5337" class="Symbol">(</a><a id="5338" href="mi.MartinLof2006.html#5313" class="Bound">f</a> <a id="5340" href="mi.MartinLof2006.html#5329" class="Bound">i</a><a id="5341" class="Symbol">)</a>
  <a id="5345" href="mi.MartinLof2006.html#5278" class="Function">ac</a> <a id="5348" href="mi.MartinLof2006.html#5348" class="Bound">p₅</a> <a id="5351" class="Symbol">=</a> <a id="5353" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="5359" href="Function.html#1099" class="Function Operator">∘</a> <a id="5361" href="mi.MartinLof2006.html#5348" class="Bound">p₅</a> <a id="5364" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="5366" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="5372" href="Function.html#1099" class="Function Operator">∘</a> <a id="5374" href="mi.MartinLof2006.html#5348" class="Bound">p₅</a>
</pre>
</div>
<div class="align-bottom">
<p>and even, more generally,</p>
<p><span class="math display">(∀i : I)(∃x : S_i)A(i, x) → (∃f : Π_{i : I} S_i)(∀i : I)A(i, f(i))</span></p>
<pre class="Agda"><a id="5508" class="Comment">-- generalized (intensional, constructive, type-theoretic) axiom of choice</a>
<a id="5583" class="Keyword">module</a> <a id="5590" href="mi.MartinLof2006.html#5590" class="Module">_</a> <a id="5592" class="Symbol">{</a><a id="5593" href="mi.MartinLof2006.html#5593" class="Bound">𝒾</a> <a id="5595" href="mi.MartinLof2006.html#5595" class="Bound">𝓈</a> <a id="5597" href="mi.MartinLof2006.html#5597" class="Bound">𝒶</a><a id="5598" class="Symbol">}</a> <a id="5600" class="Symbol">{</a><a id="5601" href="mi.MartinLof2006.html#5601" class="Bound">I</a> <a id="5603" class="Symbol">:</a> <a id="5605" class="PrimitiveType">Set</a> <a id="5609" href="mi.MartinLof2006.html#5593" class="Bound">𝒾</a><a id="5610" class="Symbol">}</a> <a id="5612" class="Symbol">{</a><a id="5613" href="mi.MartinLof2006.html#5613" class="Bound">S</a> <a id="5615" class="Symbol">:</a> <a id="5617" href="mi.MartinLof2006.html#5601" class="Bound">I</a> <a id="5619" class="Symbol">→</a> <a id="5621" class="PrimitiveType">Set</a> <a id="5625" href="mi.MartinLof2006.html#5595" class="Bound">𝓈</a><a id="5626" class="Symbol">}</a> <a id="5628" class="Symbol">{</a><a id="5629" href="mi.MartinLof2006.html#5629" class="Bound">A</a> <a id="5631" class="Symbol">:</a> <a id="5633" class="Symbol">∀</a> <a id="5635" href="mi.MartinLof2006.html#5635" class="Bound">i</a> <a id="5637" class="Symbol">→</a> <a id="5639" href="mi.MartinLof2006.html#5613" class="Bound">S</a> <a id="5641" href="mi.MartinLof2006.html#5635" class="Bound">i</a> <a id="5643" class="Symbol">→</a> <a id="5645" class="PrimitiveType">Set</a> <a id="5649" href="mi.MartinLof2006.html#5597" class="Bound">𝒶</a><a id="5650" class="Symbol">}</a> <a id="5652" class="Keyword">where</a>
  <a id="5660" href="mi.MartinLof2006.html#5660" class="Function">ac′</a> <a id="5664" class="Symbol">:</a> <a id="5666" class="Symbol">(∀</a> <a id="5669" href="mi.MartinLof2006.html#5669" class="Bound">i</a> <a id="5671" class="Symbol">→</a> <a id="5673" href="Data.Product.html#911" class="Function">Σ[</a> <a id="5676" href="mi.MartinLof2006.html#5676" class="Bound">x</a> <a id="5678" href="Data.Product.html#911" class="Function">∈</a> <a id="5680" href="mi.MartinLof2006.html#5613" class="Bound">S</a> <a id="5682" href="mi.MartinLof2006.html#5669" class="Bound">i</a> <a id="5684" href="Data.Product.html#911" class="Function">]</a> <a id="5686" href="mi.MartinLof2006.html#5629" class="Bound">A</a> <a id="5688" href="mi.MartinLof2006.html#5669" class="Bound">i</a> <a id="5690" href="mi.MartinLof2006.html#5676" class="Bound">x</a><a id="5691" class="Symbol">)</a> <a id="5693" class="Symbol">→</a> <a id="5695" href="Data.Product.html#911" class="Function">Σ[</a> <a id="5698" href="mi.MartinLof2006.html#5698" class="Bound">f</a> <a id="5700" href="Data.Product.html#911" class="Function">∈</a> <a id="5702" class="Symbol">(∀</a> <a id="5705" href="mi.MartinLof2006.html#5705" class="Bound">i</a> <a id="5707" class="Symbol">→</a> <a id="5709" href="mi.MartinLof2006.html#5613" class="Bound">S</a> <a id="5711" href="mi.MartinLof2006.html#5705" class="Bound">i</a><a id="5712" class="Symbol">)</a> <a id="5714" href="Data.Product.html#911" class="Function">]</a> <a id="5716" class="Symbol">∀</a> <a id="5718" href="mi.MartinLof2006.html#5718" class="Bound">i</a> <a id="5720" class="Symbol">→</a> <a id="5722" href="mi.MartinLof2006.html#5629" class="Bound">A</a> <a id="5724" href="mi.MartinLof2006.html#5718" class="Bound">i</a> <a id="5726" class="Symbol">(</a><a id="5727" href="mi.MartinLof2006.html#5698" class="Bound">f</a> <a id="5729" href="mi.MartinLof2006.html#5718" class="Bound">i</a><a id="5730" class="Symbol">)</a>
  <a id="5734" href="mi.MartinLof2006.html#5660" class="Function">ac′</a> <a id="5738" href="mi.MartinLof2006.html#5738" class="Bound">p₅</a> <a id="5741" class="Symbol">=</a> <a id="5743" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="5749" href="Function.html#1099" class="Function Operator">∘</a> <a id="5751" href="mi.MartinLof2006.html#5738" class="Bound">p₅</a> <a id="5754" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="5756" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="5762" href="Function.html#1099" class="Function Operator">∘</a> <a id="5764" href="mi.MartinLof2006.html#5738" class="Bound">p₅</a>
</pre>
</div>
<p>becomes evident almost immediately upon remembering the Brouwer-Heyting-Kolmogorov interpretation of the logical constants, which means that it might as well have been observed already in the early thirties. And it is this intuitive justification that was turned into a formal proof in constructive type theory, a proof that effectively uses the strong rule of <span class="math inline">∃</span>-elimination that it became possible to formulate as a result of having made the proof objects appear in the system itself and not only in its interpretation.</p>
<p>In 1975, soon after Bishop’s vindication of the constructive axiom of choice, Diaconescu proved that, in topos theory, the law of excluded middle follows from the axiom of choice.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> Now, topos theory being an intuitionistic theory, albeit impredicative, this is on the surface of it incompatible with Bishop’s observation because of the constructive inacceptability of the law of excluded middle. There is therefore a need to investigate how the constructive axiom of choice, validated by the Brouwer-Heyting-Kolmogorov interpretation, is related to Zermelo’s axiom of choice on the one hand and to the topos-theoretic axiom of choice on the other.</p>
<p>To this end, using constructive type theory as our instrument of analysis, let us simply try to prove Zermelo’s axiom of choice. This attempt should of course fail, but in the process of making it we might at least be able to discover what it is that is really objectionable about it. So what was Zermelo’s axiom of choice? In the original paper from 1904, he gave to it the following formulation,</p>
<blockquote>
<p><span lang="de"><em>Jeder Teilmenge <span class="math inline">M&#39;</span> denke man sich ein beliebiges Element <span class="math inline">m&#39;_1</span> zugeordnet, das in <span class="math inline">M&#39;</span> selbst vorkommt und das „ausgezeichnete” Element von <span class="math inline">M&#39;</span> genannt werden möge.</em></span><a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></p>
</blockquote>
<p>Here <span class="math inline">M&#39;</span> is an arbitrary subset, which contains at least one element, of a given set <span class="math inline">M.</span> What is surprising about this formulation is that there is nothing objectionable about it from a constructive point of view. Indeed, the distinguished element <span class="math inline">m&#39;_1</span> can be taken to be the left projection of the proof of the existential proposition <span class="math inline">(∃x : M)</span><span class="math inline">M&#39;(x),</span> which says that the subset <span class="math inline">M&#39;</span> of <span class="math inline">M</span> contains at least one element. This means that one would have to go into the demonstration of the well-ordering theorem in order to determine exactly what are its nonconstructive ingredients.</p>
<p>Instead of doing that, I shall turn to the formulation of the axiom of choice that Zermelo favoured in his second paper on the well-ordering theorem from 1908,</p>
<blockquote>
<p><span lang="de">Axiom. <em>Eine Menge <span class="math inline">S,</span> welche in eine Menge getrennter Teile <span class="math inline">A,</span> <span class="math inline">B,</span> <span class="math inline">C,</span> <span class="math inline">…</span> zerfällt, deren jeder mindestens ein Element enthält, besitzt mindestens eine Untermenge <span class="math inline">S_1,</span> welche mit jedem der betrachteten Teile <span class="math inline">A,</span> <span class="math inline">B,</span> <span class="math inline">C,</span> <span class="math inline">…</span> genau ein Element gemein hat.</em></span><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
</blockquote>
<div class="align-bottom">
<p>Formulated in this way, Zermelo’s axiom of choice turns out to coincide with the multiplicative axiom, which Whitehead and Russell had found indispensable for the development of the theory of cardinals.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> <a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> The type-theoretic rendering of this formulation of the axiom of choice is straightforward, once one remembers that a basic set in the sense of Cantorian set theory corresponds to an exten­sional set, that is, a set equipped with an equivalence relation, in type theory, and that a subset of an exten­sional set is interpreted as a propositional function which is exten­sional with respect to the equivalence relation in question. Thus the data of Zermelo’s 1908 formulation of the axiom of choice are a set <span class="math inline">S,</span> which comes equipped with an equivalence relation <span class="math inline">=_S,</span> and a family <span class="math inline">(A_i)_{i : I}</span> of propositional functions on <span class="math inline">S</span> satisfying the following properties,</p>
<ol type="1">
<li><p><span class="math inline">x =_S y → (A_i(x) ↔ A_i(y))</span> (exten­sionality),</p></li>
<li><p><span class="math inline">i =_I j → (∀x : S)(A_i(x) ↔ A_j(x))</span> (exten­sionality of the dependence on the index),</p></li>
<li><p><span class="math inline">(∃x : S)(A_i(x)\ \&amp;\ A_j(x)) → i =_I j</span> (mutual exclusive­ness),</p></li>
<li><p><span class="math inline">(∀x : S)(∃i : I)A_i(x)</span> (exhaustiveness),</p></li>
<li><p><span class="math inline">(∀i : I)(∃x : S)A_i(x)</span> (non-emptiness).</p></li>
</ol>
<pre class="Agda"><a id="9844" class="Keyword">module</a> <a id="9851" href="mi.MartinLof2006.html#9851" class="Module">_</a> <a id="9853" class="Symbol">{</a><a id="9854" href="mi.MartinLof2006.html#9854" class="Bound">𝒾</a> <a id="9856" href="mi.MartinLof2006.html#9856" class="Bound">𝒾ₑ</a><a id="9858" class="Symbol">}</a> <a id="9860" class="Symbol">(</a><a id="9861" href="mi.MartinLof2006.html#9861" class="Bound">Iₑ</a> <a id="9864" class="Symbol">:</a> <a id="9866" href="Relation.Binary.html#1970" class="Record">Setoid</a> <a id="9873" href="mi.MartinLof2006.html#9854" class="Bound">𝒾</a> <a id="9875" href="mi.MartinLof2006.html#9856" class="Bound">𝒾ₑ</a><a id="9877" class="Symbol">)</a> <a id="9879" class="Keyword">where</a>
  <a id="9887" class="Keyword">private</a> <a id="9895" class="Keyword">open</a> <a id="9900" class="Keyword">module</a> <a id="I"></a><a id="9907" href="mi.MartinLof2006.html#9907" class="Module">I</a> <a id="9909" class="Symbol">=</a> <a id="9911" href="Relation.Binary.html#1970" class="Module">Setoid</a> <a id="9918" href="mi.MartinLof2006.html#9861" class="Bound">Iₑ</a> <a id="9921" class="Keyword">using</a> <a id="9927" class="Symbol">()</a> <a id="9930" class="Keyword">renaming</a> <a id="9939" class="Symbol">(</a><a id="9940" href="Relation.Binary.html#2033" class="Field">Carrier</a> <a id="9948" class="Symbol">to</a> <a id="9951" href="Relation.Binary.html#2033" class="Field">I</a><a id="9952" class="Symbol">)</a>

  <a id="9957" class="Keyword">module</a> <a id="9964" href="mi.MartinLof2006.html#9964" class="Module">_</a> <a id="9966" class="Symbol">{</a><a id="9967" href="mi.MartinLof2006.html#9967" class="Bound">𝓈</a> <a id="9969" href="mi.MartinLof2006.html#9969" class="Bound">𝓈ₑ</a><a id="9971" class="Symbol">}</a> <a id="9973" class="Symbol">(</a><a id="9974" href="mi.MartinLof2006.html#9974" class="Bound">Sₑ</a> <a id="9977" class="Symbol">:</a> <a id="9979" href="Relation.Binary.html#1970" class="Record">Setoid</a> <a id="9986" href="mi.MartinLof2006.html#9967" class="Bound">𝓈</a> <a id="9988" href="mi.MartinLof2006.html#9969" class="Bound">𝓈ₑ</a><a id="9990" class="Symbol">)</a> <a id="9992" class="Keyword">where</a>
    <a id="10002" class="Keyword">private</a> <a id="10010" class="Keyword">open</a> <a id="10015" class="Keyword">module</a> <a id="S"></a><a id="10022" href="mi.MartinLof2006.html#10022" class="Module">S</a> <a id="10024" class="Symbol">=</a> <a id="10026" href="Relation.Binary.html#1970" class="Module">Setoid</a> <a id="10033" href="mi.MartinLof2006.html#9974" class="Bound">Sₑ</a> <a id="10036" class="Keyword">using</a> <a id="10042" class="Symbol">()</a> <a id="10045" class="Keyword">renaming</a> <a id="10054" class="Symbol">(</a><a id="10055" href="Relation.Binary.html#2033" class="Field">Carrier</a> <a id="10063" class="Symbol">to</a> <a id="10066" href="Relation.Binary.html#2033" class="Field">S</a><a id="10067" class="Symbol">)</a>

    <a id="10074" href="mi.MartinLof2006.html#10074" class="Function">Ext</a> <a id="10078" class="Symbol">:</a> <a id="10080" class="Symbol">∀</a> <a id="10082" class="Symbol">(</a><a id="10083" href="mi.MartinLof2006.html#10083" class="Bound">f</a> <a id="10085" class="Symbol">:</a> <a id="10087" href="Relation.Binary.html#2033" class="Field">I</a> <a id="10089" class="Symbol">→</a> <a id="10091" href="Relation.Binary.html#2033" class="Field">S</a><a id="10092" class="Symbol">)</a> <a id="10094" class="Symbol">→</a> <a id="10096" class="PrimitiveType">Set</a> <a id="10100" class="Symbol">_</a>
    <a id="10106" href="mi.MartinLof2006.html#10074" class="Function">Ext</a> <a id="10110" href="mi.MartinLof2006.html#10110" class="Bound">f</a> <a id="10112" class="Symbol">=</a> <a id="10114" class="Symbol">∀</a> <a id="10116" class="Symbol">{</a><a id="10117" href="mi.MartinLof2006.html#10117" class="Bound">i</a> <a id="10119" href="mi.MartinLof2006.html#10119" class="Bound">j</a><a id="10120" class="Symbol">}</a> <a id="10122" class="Symbol">→</a> <a id="10124" href="mi.MartinLof2006.html#10117" class="Bound">i</a> <a id="10126" href="Relation.Binary.html#2059" class="Field Operator">I.≈</a> <a id="10130" href="mi.MartinLof2006.html#10119" class="Bound">j</a> <a id="10132" class="Symbol">→</a> <a id="10134" href="mi.MartinLof2006.html#10110" class="Bound">f</a> <a id="10136" href="mi.MartinLof2006.html#10117" class="Bound">i</a> <a id="10138" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="10142" href="mi.MartinLof2006.html#10110" class="Bound">f</a> <a id="10144" href="mi.MartinLof2006.html#10119" class="Bound">j</a>

    <a id="10151" class="Keyword">module</a> <a id="10158" href="mi.MartinLof2006.html#10158" class="Module">_</a> <a id="10160" class="Symbol">{</a><a id="10161" href="mi.MartinLof2006.html#10161" class="Bound">𝒶</a><a id="10162" class="Symbol">}</a> <a id="10164" class="Symbol">(</a><a id="10165" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10167" class="Symbol">:</a> <a id="10169" href="Relation.Binary.html#2033" class="Field">I</a> <a id="10171" class="Symbol">→</a> <a id="10173" href="Relation.Binary.html#2033" class="Field">S</a> <a id="10175" class="Symbol">→</a> <a id="10177" class="PrimitiveType">Set</a> <a id="10181" href="mi.MartinLof2006.html#10161" class="Bound">𝒶</a><a id="10182" class="Symbol">)</a> <a id="10184" class="Keyword">where</a>
      <a id="10196" class="Comment">-- extensionality</a>
      <a id="10220" href="mi.MartinLof2006.html#10220" class="Function">P₁</a> <a id="10223" class="Symbol">=</a> <a id="10225" class="Symbol">∀</a> <a id="10227" class="Symbol">{</a><a id="10228" href="mi.MartinLof2006.html#10228" class="Bound">i</a> <a id="10230" href="mi.MartinLof2006.html#10230" class="Bound">x</a> <a id="10232" href="mi.MartinLof2006.html#10232" class="Bound">y</a><a id="10233" class="Symbol">}</a> <a id="10235" class="Symbol">→</a> <a id="10237" href="mi.MartinLof2006.html#10230" class="Bound">x</a> <a id="10239" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="10243" href="mi.MartinLof2006.html#10232" class="Bound">y</a> <a id="10245" class="Symbol">→</a> <a id="10247" class="Symbol">(</a><a id="10248" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10250" href="mi.MartinLof2006.html#10228" class="Bound">i</a> <a id="10252" href="mi.MartinLof2006.html#10230" class="Bound">x</a> <a id="10254" href="mi.MartinLof2006.html#737" class="Function Operator">↔</a> <a id="10256" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10258" href="mi.MartinLof2006.html#10228" class="Bound">i</a> <a id="10260" href="mi.MartinLof2006.html#10232" class="Bound">y</a><a id="10261" class="Symbol">)</a>

      <a id="10270" class="Comment">-- extensionality of the dependence on the index</a>
      <a id="10325" href="mi.MartinLof2006.html#10325" class="Function">P₂</a> <a id="10328" class="Symbol">=</a> <a id="10330" class="Symbol">∀</a> <a id="10332" class="Symbol">{</a><a id="10333" href="mi.MartinLof2006.html#10333" class="Bound">i</a> <a id="10335" href="mi.MartinLof2006.html#10335" class="Bound">j</a><a id="10336" class="Symbol">}</a> <a id="10338" class="Symbol">→</a> <a id="10340" href="mi.MartinLof2006.html#10333" class="Bound">i</a> <a id="10342" href="Relation.Binary.html#2059" class="Field Operator">I.≈</a> <a id="10346" href="mi.MartinLof2006.html#10335" class="Bound">j</a> <a id="10348" class="Symbol">→</a> <a id="10350" class="Symbol">∀</a> <a id="10352" href="mi.MartinLof2006.html#10352" class="Bound">x</a> <a id="10354" class="Symbol">→</a> <a id="10356" class="Symbol">(</a><a id="10357" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10359" href="mi.MartinLof2006.html#10333" class="Bound">i</a> <a id="10361" href="mi.MartinLof2006.html#10352" class="Bound">x</a> <a id="10363" href="mi.MartinLof2006.html#737" class="Function Operator">↔</a> <a id="10365" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10367" href="mi.MartinLof2006.html#10335" class="Bound">j</a> <a id="10369" href="mi.MartinLof2006.html#10352" class="Bound">x</a><a id="10370" class="Symbol">)</a>

      <a id="10379" class="Comment">-- mutual exclusiveness</a>
      <a id="10409" href="mi.MartinLof2006.html#10409" class="Function">P₃</a> <a id="10412" class="Symbol">=</a> <a id="10414" class="Symbol">∀</a> <a id="10416" class="Symbol">{</a><a id="10417" href="mi.MartinLof2006.html#10417" class="Bound">i</a> <a id="10419" href="mi.MartinLof2006.html#10419" class="Bound">j</a><a id="10420" class="Symbol">}</a> <a id="10422" class="Symbol">→</a> <a id="10424" class="Symbol">(</a><a id="10425" href="Data.Product.html#911" class="Function">Σ[</a> <a id="10428" href="mi.MartinLof2006.html#10428" class="Bound">x</a> <a id="10430" href="Data.Product.html#911" class="Function">∈</a> <a id="10432" href="Relation.Binary.html#2033" class="Field">S</a> <a id="10434" href="Data.Product.html#911" class="Function">]</a> <a id="10436" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10438" href="mi.MartinLof2006.html#10417" class="Bound">i</a> <a id="10440" href="mi.MartinLof2006.html#10428" class="Bound">x</a> <a id="10442" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="10444" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10446" href="mi.MartinLof2006.html#10419" class="Bound">j</a> <a id="10448" href="mi.MartinLof2006.html#10428" class="Bound">x</a><a id="10449" class="Symbol">)</a> <a id="10451" class="Symbol">→</a> <a id="10453" href="mi.MartinLof2006.html#10417" class="Bound">i</a> <a id="10455" href="Relation.Binary.html#2059" class="Field Operator">I.≈</a> <a id="10459" href="mi.MartinLof2006.html#10419" class="Bound">j</a>

      <a id="10468" class="Comment">-- exhaustiveness</a>
      <a id="10492" href="mi.MartinLof2006.html#10492" class="Function">P₄</a> <a id="10495" class="Symbol">=</a> <a id="10497" class="Symbol">∀</a> <a id="10499" href="mi.MartinLof2006.html#10499" class="Bound">x</a> <a id="10501" class="Symbol">→</a> <a id="10503" href="Data.Product.html#911" class="Function">Σ[</a> <a id="10506" href="mi.MartinLof2006.html#10506" class="Bound">i</a> <a id="10508" href="Data.Product.html#911" class="Function">∈</a> <a id="10510" href="Relation.Binary.html#2033" class="Field">I</a> <a id="10512" href="Data.Product.html#911" class="Function">]</a> <a id="10514" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10516" href="mi.MartinLof2006.html#10506" class="Bound">i</a> <a id="10518" href="mi.MartinLof2006.html#10499" class="Bound">x</a>

      <a id="10527" class="Comment">-- nonemptiness</a>
      <a id="10549" href="mi.MartinLof2006.html#10549" class="Function">P₅</a> <a id="10552" class="Symbol">=</a> <a id="10554" class="Symbol">∀</a> <a id="10556" href="mi.MartinLof2006.html#10556" class="Bound">i</a> <a id="10558" class="Symbol">→</a> <a id="10560" href="Data.Product.html#911" class="Function">Σ[</a> <a id="10563" href="mi.MartinLof2006.html#10563" class="Bound">x</a> <a id="10565" href="Data.Product.html#911" class="Function">∈</a> <a id="10567" href="Relation.Binary.html#2033" class="Field">S</a> <a id="10569" href="Data.Product.html#911" class="Function">]</a> <a id="10571" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="10573" href="mi.MartinLof2006.html#10556" class="Bound">i</a> <a id="10575" href="mi.MartinLof2006.html#10563" class="Bound">x</a>
</pre>
</div>
<div class="align-bottom">
<p>Given these data, the axiom guarantees the existence of a propositional function <span class="math inline">S_1</span> on <span class="math inline">S</span> such that</p>
<ol start="6" type="1">
<li><p><span class="math inline">x =_S y → (S_1(x) ↔ S_1(y))</span> (exten­sionality),</p></li>
<li><p><span class="math inline">(∀i : I)(∃!x : S)(A_i ∩ S_1)(x)</span> (uniqueness of choice).</p></li>
</ol>
<pre class="Agda">      <a id="10842" class="Keyword">module</a> <a id="10849" href="mi.MartinLof2006.html#10849" class="Module">_</a> <a id="10851" class="Symbol">{</a><a id="10852" href="mi.MartinLof2006.html#10852" class="Bound">𝓈₁</a><a id="10854" class="Symbol">}</a> <a id="10856" class="Symbol">(</a><a id="10857" href="mi.MartinLof2006.html#10857" class="Bound">S₁</a> <a id="10860" class="Symbol">:</a> <a id="10862" href="Relation.Binary.html#2033" class="Field">S</a> <a id="10864" class="Symbol">→</a> <a id="10866" class="PrimitiveType">Set</a> <a id="10870" href="mi.MartinLof2006.html#10852" class="Bound">𝓈₁</a><a id="10872" class="Symbol">)</a> <a id="10874" class="Keyword">where</a>
        <a id="10888" class="Comment">-- extensionality</a>
        <a id="10914" href="mi.MartinLof2006.html#10914" class="Function">P₆</a> <a id="10917" class="Symbol">=</a> <a id="10919" class="Symbol">∀</a> <a id="10921" class="Symbol">{</a><a id="10922" href="mi.MartinLof2006.html#10922" class="Bound">x</a> <a id="10924" href="mi.MartinLof2006.html#10924" class="Bound">y</a><a id="10925" class="Symbol">}</a> <a id="10927" class="Symbol">→</a> <a id="10929" href="mi.MartinLof2006.html#10922" class="Bound">x</a> <a id="10931" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="10935" href="mi.MartinLof2006.html#10924" class="Bound">y</a> <a id="10937" class="Symbol">→</a> <a id="10939" class="Symbol">(</a><a id="10940" href="mi.MartinLof2006.html#10857" class="Bound">S₁</a> <a id="10943" href="mi.MartinLof2006.html#10922" class="Bound">x</a> <a id="10945" href="mi.MartinLof2006.html#737" class="Function Operator">↔</a> <a id="10947" href="mi.MartinLof2006.html#10857" class="Bound">S₁</a> <a id="10950" href="mi.MartinLof2006.html#10924" class="Bound">y</a><a id="10951" class="Symbol">)</a>

        <a id="10962" class="Comment">-- uniqueness of choice</a>
        <a id="10994" href="mi.MartinLof2006.html#10994" class="Function">P₇</a> <a id="10997" class="Symbol">=</a> <a id="10999" class="Symbol">∀</a> <a id="11001" href="mi.MartinLof2006.html#11001" class="Bound">i</a> <a id="11003" class="Symbol">→</a> <a id="11005" href="mi.MartinLof2006.html#810" class="Function">Σ![</a> <a id="11009" href="mi.MartinLof2006.html#11009" class="Bound">x</a> <a id="11011" href="mi.MartinLof2006.html#810" class="Function">∈</a> <a id="11013" href="Relation.Binary.html#2033" class="Field">S</a> <a id="11015" href="mi.MartinLof2006.html#810" class="Function">/</a> <a id="11017" href="Relation.Binary.html#2059" class="Field Operator">S._≈_</a> <a id="11023" href="mi.MartinLof2006.html#810" class="Function">]</a> <a id="11025" class="Symbol">(</a><a id="11026" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="11028" href="mi.MartinLof2006.html#11001" class="Bound">i</a> <a id="11030" href="Relation.Unary.html#4268" class="Function Operator">∩</a> <a id="11032" href="mi.MartinLof2006.html#10857" class="Bound">S₁</a><a id="11034" class="Symbol">)</a> <a id="11036" href="mi.MartinLof2006.html#11009" class="Bound">x</a>
</pre>
</div>
<p>The obvious way of trying to prove (6) and (7) from (1)–(5) is to apply the type-theoretic (constructive, inten­sional) axiom of choice to (5), so as to get a function <span class="math inline">f : I → S</span> such that</p>
<p><span class="math display">(∀i : I)A_i(f(i)),</span></p>
<p>and then define <span class="math inline">S_1</span> by the equation</p>
<p><span class="math display">S_1 = \{f(j)\ |\ j : I\} = \{x\ |\ (∃j : I)(f(j)) =_S x)\}.</span></p>
<p>Defined in this way, <span class="math inline">S_1</span> is clearly exten­sional, which is to say that it satisfies (6). What about (7)? Since the proposition</p>
<p><span class="math display">(A_i ∩ S_1)(f(i)) = A_i(f(i))\ \&amp;\ S_1(f(i))</span></p>
<p>is clearly true, so is</p>
<p><span class="math display">(∀i : I)(∃x : S)(A_i ∩ S_1)(x),</span></p>
<p>which means that only the uniqueness condition remains to be proved. To this end, assume that the proposition</p>
<p><span class="math display">(A_i ∩ S_1)(x) = A_i(x)\ \&amp;\ S_1(x)</span></p>
<p>is true, that is, that the two propositions</p>
<p><span class="math display">
\begin{cases}
  A_i(x),\\
  S_1(x) = (∃j : I)(f(j) =_S x),
\end{cases}
</span></p>
<p>are both true. Let <span class="math inline">j : I</span> satisfy <span class="math inline">f(j) =_S x.</span> Then, since <span class="math inline">(∀i : I)</span><span class="math inline">A_i(f(i))</span> is true, so is <span class="math inline">A_j(f(j)).</span> Hence, by the exten­sionality of <span class="math inline">A_j</span> with respect to <span class="math inline">=_S,</span> <span class="math inline">A_j(x)</span> is true, which, together with the assumed truth of <span class="math inline">A_i(x),</span> yields <span class="math inline">i =_I j</span> by the mutual exclusiveness of the family of subsets <span class="math inline">(A_i)_{i : I}.</span> At this stage, in order to conclude that <span class="math inline">f(i) =_S x,</span> we need to know that the choice function <span class="math inline">f</span> is exten­sional, that is, that</p>
<p><span class="math display">i =_I j → f(i) =_S f(j).</span></p>
<pre class="Agda">      <a id="12407" class="Comment">-- Zermelo’s axiom of choice</a>
      <a id="12442" href="mi.MartinLof2006.html#12442" class="Function">ZerAC</a> <a id="12448" class="Symbol">=</a> <a id="12450" class="Symbol">(</a><a id="12451" href="mi.MartinLof2006.html#10220" class="Function">P₁</a> <a id="12454" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="12456" href="mi.MartinLof2006.html#10325" class="Function">P₂</a> <a id="12459" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="12461" href="mi.MartinLof2006.html#10409" class="Function">P₃</a> <a id="12464" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="12466" href="mi.MartinLof2006.html#10492" class="Function">P₄</a> <a id="12469" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="12471" href="mi.MartinLof2006.html#10549" class="Function">P₅</a><a id="12473" class="Symbol">)</a> <a id="12475" class="Symbol">→</a> <a id="12477" href="Data.Product.html#911" class="Function">Σ[</a> <a id="12480" href="mi.MartinLof2006.html#12480" class="Bound">S₁</a> <a id="12483" href="Data.Product.html#911" class="Function">∈</a> <a id="12485" class="Symbol">(</a><a id="12486" href="Relation.Binary.html#2033" class="Field">S</a> <a id="12488" class="Symbol">→</a> <a id="12490" class="PrimitiveType">Set</a> <a id="12494" class="Symbol">(</a><a id="12495" href="mi.MartinLof2006.html#9854" class="Bound">𝒾</a> <a id="12497" href="Agda.Primitive.html#657" class="Primitive Operator">⊔</a> <a id="12499" href="mi.MartinLof2006.html#9969" class="Bound">𝓈ₑ</a><a id="12501" class="Symbol">))</a> <a id="12504" href="Data.Product.html#911" class="Function">]</a> <a id="12506" class="Symbol">(</a><a id="12507" href="mi.MartinLof2006.html#10914" class="Function">P₆</a> <a id="12510" href="mi.MartinLof2006.html#12480" class="Bound">S₁</a> <a id="12513" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="12515" href="mi.MartinLof2006.html#10994" class="Function">P₇</a> <a id="12518" href="mi.MartinLof2006.html#12480" class="Bound">S₁</a><a id="12520" class="Symbol">)</a>

      <a id="12529" class="Comment">-- extensional axiom of choice</a>
      <a id="12566" href="mi.MartinLof2006.html#12566" class="Function">ExtAC</a> <a id="12572" class="Symbol">=</a> <a id="12574" class="Symbol">(∀</a> <a id="12577" href="mi.MartinLof2006.html#12577" class="Bound">i</a> <a id="12579" class="Symbol">→</a> <a id="12581" href="Data.Product.html#911" class="Function">Σ[</a> <a id="12584" href="mi.MartinLof2006.html#12584" class="Bound">x</a> <a id="12586" href="Data.Product.html#911" class="Function">∈</a> <a id="12588" href="Relation.Binary.html#2033" class="Field">S</a> <a id="12590" href="Data.Product.html#911" class="Function">]</a> <a id="12592" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="12594" href="mi.MartinLof2006.html#12577" class="Bound">i</a> <a id="12596" href="mi.MartinLof2006.html#12584" class="Bound">x</a><a id="12597" class="Symbol">)</a> <a id="12599" class="Symbol">→</a> <a id="12601" href="Data.Product.html#911" class="Function">Σ[</a> <a id="12604" href="mi.MartinLof2006.html#12604" class="Bound">f</a> <a id="12606" href="Data.Product.html#911" class="Function">∈</a> <a id="12608" class="Symbol">(</a><a id="12609" href="Relation.Binary.html#2033" class="Field">I</a> <a id="12611" class="Symbol">→</a> <a id="12613" href="Relation.Binary.html#2033" class="Field">S</a><a id="12614" class="Symbol">)</a> <a id="12616" href="Data.Product.html#911" class="Function">]</a> <a id="12618" href="mi.MartinLof2006.html#10074" class="Function">Ext</a> <a id="12622" href="mi.MartinLof2006.html#12604" class="Bound">f</a> <a id="12624" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="12626" class="Symbol">∀</a> <a id="12628" href="mi.MartinLof2006.html#12628" class="Bound">i</a> <a id="12630" class="Symbol">→</a> <a id="12632" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="12634" href="mi.MartinLof2006.html#12628" class="Bound">i</a> <a id="12636" class="Symbol">(</a><a id="12637" href="mi.MartinLof2006.html#12604" class="Bound">f</a> <a id="12639" href="mi.MartinLof2006.html#12628" class="Bound">i</a><a id="12640" class="Symbol">)</a>

      <a id="12649" href="mi.MartinLof2006.html#12649" class="Function">zerac</a> <a id="12655" class="Symbol">:</a> <a id="12657" href="mi.MartinLof2006.html#12566" class="Function">ExtAC</a> <a id="12663" class="Symbol">→</a> <a id="12665" href="mi.MartinLof2006.html#12442" class="Function">ZerAC</a>
      <a id="12677" href="mi.MartinLof2006.html#12649" class="Function">zerac</a> <a id="12683" href="mi.MartinLof2006.html#12683" class="Bound">extac</a> <a id="12689" class="Symbol">(</a><a id="12690" href="mi.MartinLof2006.html#12690" class="Bound">p₁</a> <a id="12693" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12695" href="mi.MartinLof2006.html#12695" class="Bound">p₂</a> <a id="12698" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12700" href="mi.MartinLof2006.html#12700" class="Bound">p₃</a> <a id="12703" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12705" class="Symbol">_</a> <a id="12707" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12709" href="mi.MartinLof2006.html#12709" class="Bound">p₅</a><a id="12711" class="Symbol">)</a>  <a id="12714" class="Symbol">=</a>
        <a id="12724" class="Keyword">let</a>
          <a id="12738" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="12740" class="Symbol">:</a> <a id="12742" href="Relation.Binary.html#2033" class="Field">I</a> <a id="12744" class="Symbol">→</a> <a id="12746" href="Relation.Binary.html#2033" class="Field">S</a>
          <a id="12758" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="12760" class="Symbol">=</a> <a id="12762" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="12768" class="Symbol">(</a><a id="12769" href="mi.MartinLof2006.html#12683" class="Bound">extac</a> <a id="12775" href="mi.MartinLof2006.html#12709" class="Bound">p₅</a><a id="12777" class="Symbol">)</a>

          <a id="12790" href="mi.MartinLof2006.html#12790" class="Bound">Ext[f]</a> <a id="12797" class="Symbol">:</a> <a id="12799" href="mi.MartinLof2006.html#10074" class="Function">Ext</a> <a id="12803" href="mi.MartinLof2006.html#12738" class="Bound">f</a>
          <a id="12815" href="mi.MartinLof2006.html#12790" class="Bound">Ext[f]</a> <a id="12822" class="Symbol">=</a> <a id="12824" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="12830" class="Symbol">(</a><a id="12831" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="12837" class="Symbol">(</a><a id="12838" href="mi.MartinLof2006.html#12683" class="Bound">extac</a> <a id="12844" href="mi.MartinLof2006.html#12709" class="Bound">p₅</a><a id="12846" class="Symbol">))</a>

          <a id="12860" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a> <a id="12863" class="Symbol">:</a> <a id="12865" href="Relation.Binary.html#2033" class="Field">S</a> <a id="12867" class="Symbol">→</a> <a id="12869" class="PrimitiveType">Set</a> <a id="12873" class="Symbol">_</a>
          <a id="12885" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a> <a id="12888" href="mi.MartinLof2006.html#12888" class="Bound">x</a> <a id="12890" class="Symbol">=</a> <a id="12892" href="Data.Product.html#911" class="Function">Σ[</a> <a id="12895" href="mi.MartinLof2006.html#12895" class="Bound">j</a> <a id="12897" href="Data.Product.html#911" class="Function">∈</a> <a id="12899" href="Relation.Binary.html#2033" class="Field">I</a> <a id="12901" href="Data.Product.html#911" class="Function">]</a> <a id="12903" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="12905" href="mi.MartinLof2006.html#12895" class="Bound">j</a> <a id="12907" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="12911" href="mi.MartinLof2006.html#12888" class="Bound">x</a>

          <a id="12924" href="mi.MartinLof2006.html#12924" class="Bound">p₆</a> <a id="12927" class="Symbol">:</a> <a id="12929" class="Symbol">∀</a> <a id="12931" class="Symbol">{</a><a id="12932" href="mi.MartinLof2006.html#12932" class="Bound">x</a> <a id="12934" href="mi.MartinLof2006.html#12934" class="Bound">y</a><a id="12935" class="Symbol">}</a> <a id="12937" class="Symbol">→</a> <a id="12939" href="mi.MartinLof2006.html#12932" class="Bound">x</a> <a id="12941" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="12945" href="mi.MartinLof2006.html#12934" class="Bound">y</a> <a id="12947" class="Symbol">→</a> <a id="12949" class="Symbol">(</a><a id="12950" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a> <a id="12953" href="mi.MartinLof2006.html#12932" class="Bound">x</a> <a id="12955" href="mi.MartinLof2006.html#737" class="Function Operator">↔</a> <a id="12957" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a> <a id="12960" href="mi.MartinLof2006.html#12934" class="Bound">y</a><a id="12961" class="Symbol">)</a>
          <a id="12973" href="mi.MartinLof2006.html#12924" class="Bound">p₆</a> <a id="12976" href="mi.MartinLof2006.html#12976" class="Bound">x≈y</a> <a id="12980" class="Symbol">=</a> <a id="12982" class="Symbol">(λ</a> <a id="12985" class="Symbol">{</a> <a id="12987" class="Symbol">(</a><a id="12988" href="mi.MartinLof2006.html#12988" class="Bound">j</a> <a id="12990" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12992" href="mi.MartinLof2006.html#12992" class="Bound">fj≈x</a><a id="12996" class="Symbol">)</a> <a id="12998" class="Symbol">→</a> <a id="13000" href="mi.MartinLof2006.html#12988" class="Bound">j</a> <a id="13002" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13004" href="Relation.Binary.Core.html#7072" class="Function">S.trans</a> <a id="13012" href="mi.MartinLof2006.html#12992" class="Bound">fj≈x</a> <a id="13017" href="mi.MartinLof2006.html#12976" class="Bound">x≈y</a> <a id="13021" class="Symbol">})</a> <a id="13024" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a>
                   <a id="13045" class="Symbol">(λ</a> <a id="13048" class="Symbol">{</a> <a id="13050" class="Symbol">(</a><a id="13051" href="mi.MartinLof2006.html#13051" class="Bound">j</a> <a id="13053" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13055" href="mi.MartinLof2006.html#13055" class="Bound">fj≈x</a><a id="13059" class="Symbol">)</a> <a id="13061" class="Symbol">→</a> <a id="13063" href="mi.MartinLof2006.html#13051" class="Bound">j</a> <a id="13065" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13067" href="Relation.Binary.Core.html#7072" class="Function">S.trans</a> <a id="13075" href="mi.MartinLof2006.html#13055" class="Bound">fj≈x</a> <a id="13080" class="Symbol">(</a><a id="13081" href="Relation.Binary.Core.html#7046" class="Function">S.sym</a> <a id="13087" href="mi.MartinLof2006.html#12976" class="Bound">x≈y</a><a id="13090" class="Symbol">)</a> <a id="13092" class="Symbol">})</a>

          <a id="13106" href="mi.MartinLof2006.html#13106" class="Bound">clearlyTrue</a> <a id="13118" class="Symbol">:</a> <a id="13120" class="Symbol">∀</a> <a id="13122" href="mi.MartinLof2006.html#13122" class="Bound">i</a> <a id="13124" class="Symbol">→</a> <a id="13126" class="Symbol">(</a><a id="13127" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="13129" href="mi.MartinLof2006.html#13122" class="Bound">i</a> <a id="13131" href="Relation.Unary.html#4268" class="Function Operator">∩</a> <a id="13133" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a><a id="13135" class="Symbol">)</a> <a id="13137" class="Symbol">(</a><a id="13138" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13140" href="mi.MartinLof2006.html#13122" class="Bound">i</a><a id="13141" class="Symbol">)</a>
          <a id="13153" href="mi.MartinLof2006.html#13106" class="Bound">clearlyTrue</a> <a id="13165" href="mi.MartinLof2006.html#13165" class="Bound">i</a> <a id="13167" class="Symbol">=</a> <a id="13169" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="13175" class="Symbol">(</a><a id="13176" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="13182" class="Symbol">(</a><a id="13183" href="mi.MartinLof2006.html#12683" class="Bound">extac</a> <a id="13189" href="mi.MartinLof2006.html#12709" class="Bound">p₅</a><a id="13191" class="Symbol">))</a> <a id="13194" href="mi.MartinLof2006.html#13165" class="Bound">i</a> <a id="13196" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13198" href="mi.MartinLof2006.html#13165" class="Bound">i</a> <a id="13200" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13202" href="Relation.Binary.Core.html#7020" class="Function">S.refl</a>

          <a id="13220" href="mi.MartinLof2006.html#13220" class="Bound">soIs</a> <a id="13225" class="Symbol">:</a> <a id="13227" class="Symbol">∀</a> <a id="13229" href="mi.MartinLof2006.html#13229" class="Bound">i</a> <a id="13231" class="Symbol">→</a> <a id="13233" href="Data.Product.html#911" class="Function">Σ[</a> <a id="13236" href="mi.MartinLof2006.html#13236" class="Bound">x</a> <a id="13238" href="Data.Product.html#911" class="Function">∈</a> <a id="13240" href="Relation.Binary.html#2033" class="Field">S</a> <a id="13242" href="Data.Product.html#911" class="Function">]</a> <a id="13244" class="Symbol">(</a><a id="13245" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="13247" href="mi.MartinLof2006.html#13229" class="Bound">i</a> <a id="13249" href="Relation.Unary.html#4268" class="Function Operator">∩</a> <a id="13251" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a><a id="13253" class="Symbol">)</a> <a id="13255" href="mi.MartinLof2006.html#13236" class="Bound">x</a>
          <a id="13267" href="mi.MartinLof2006.html#13220" class="Bound">soIs</a> <a id="13272" href="mi.MartinLof2006.html#13272" class="Bound">i</a> <a id="13274" class="Symbol">=</a> <a id="13276" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13278" href="mi.MartinLof2006.html#13272" class="Bound">i</a> <a id="13280" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13282" href="mi.MartinLof2006.html#13106" class="Bound">clearlyTrue</a> <a id="13294" href="mi.MartinLof2006.html#13272" class="Bound">i</a>

          <a id="13307" href="mi.MartinLof2006.html#13307" class="Bound">p₇</a> <a id="13310" class="Symbol">:</a> <a id="13312" class="Symbol">∀</a> <a id="13314" href="mi.MartinLof2006.html#13314" class="Bound">i</a> <a id="13316" class="Symbol">→</a> <a id="13318" href="mi.MartinLof2006.html#810" class="Function">Σ![</a> <a id="13322" href="mi.MartinLof2006.html#13322" class="Bound">x</a> <a id="13324" href="mi.MartinLof2006.html#810" class="Function">∈</a> <a id="13326" href="Relation.Binary.html#2033" class="Field">S</a> <a id="13328" href="mi.MartinLof2006.html#810" class="Function">/</a> <a id="13330" href="Relation.Binary.html#2059" class="Field Operator">S._≈_</a> <a id="13336" href="mi.MartinLof2006.html#810" class="Function">]</a> <a id="13338" class="Symbol">(</a><a id="13339" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="13341" href="mi.MartinLof2006.html#13314" class="Bound">i</a> <a id="13343" href="Relation.Unary.html#4268" class="Function Operator">∩</a> <a id="13345" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a><a id="13347" class="Symbol">)</a> <a id="13349" href="mi.MartinLof2006.html#13322" class="Bound">x</a>
          <a id="13361" href="mi.MartinLof2006.html#13307" class="Bound">p₇</a> <a id="13364" href="mi.MartinLof2006.html#13364" class="Bound">i</a> <a id="13366" class="Symbol">=</a> <a id="13368" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13370" href="mi.MartinLof2006.html#13364" class="Bound">i</a> <a id="13372" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13374" href="mi.MartinLof2006.html#13106" class="Bound">clearlyTrue</a> <a id="13386" href="mi.MartinLof2006.html#13364" class="Bound">i</a> <a id="13388" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13390" class="Symbol">λ</a> <a id="13392" class="Symbol">{</a> <a id="13394" class="Symbol">{</a><a id="13395" href="mi.MartinLof2006.html#13395" class="Bound">y</a><a id="13396" class="Symbol">}</a> <a id="13398" class="Symbol">(</a><a id="13399" href="mi.MartinLof2006.html#13399" class="Bound">Aiy</a> <a id="13403" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13405" href="mi.MartinLof2006.html#13405" class="Bound">j</a> <a id="13407" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13409" href="mi.MartinLof2006.html#13409" class="Bound">fj≈y</a><a id="13413" class="Symbol">)</a> <a id="13415" class="Symbol">→</a>
            <a id="13429" class="Keyword">let</a>
              <a id="13447" href="mi.MartinLof2006.html#13447" class="Bound">Aj[fj]</a> <a id="13454" class="Symbol">:</a> <a id="13456" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="13458" href="mi.MartinLof2006.html#13405" class="Bound">j</a> <a id="13460" class="Symbol">(</a><a id="13461" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13463" href="mi.MartinLof2006.html#13405" class="Bound">j</a><a id="13464" class="Symbol">)</a>
              <a id="13480" href="mi.MartinLof2006.html#13447" class="Bound">Aj[fj]</a> <a id="13487" class="Symbol">=</a> <a id="13489" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="13495" class="Symbol">(</a><a id="13496" href="mi.MartinLof2006.html#13106" class="Bound">clearlyTrue</a> <a id="13508" href="mi.MartinLof2006.html#13405" class="Bound">j</a><a id="13509" class="Symbol">)</a>

              <a id="13526" href="mi.MartinLof2006.html#13526" class="Bound">Ajy</a> <a id="13530" class="Symbol">:</a> <a id="13532" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="13534" href="mi.MartinLof2006.html#13405" class="Bound">j</a> <a id="13536" href="mi.MartinLof2006.html#13395" class="Bound">y</a>
              <a id="13552" href="mi.MartinLof2006.html#13526" class="Bound">Ajy</a> <a id="13556" class="Symbol">=</a> <a id="13558" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="13564" class="Symbol">(</a><a id="13565" href="mi.MartinLof2006.html#12690" class="Bound">p₁</a> <a id="13568" href="mi.MartinLof2006.html#13409" class="Bound">fj≈y</a><a id="13572" class="Symbol">)</a> <a id="13574" href="mi.MartinLof2006.html#13447" class="Bound">Aj[fj]</a>

              <a id="13596" href="mi.MartinLof2006.html#13596" class="Bound">i≈j</a> <a id="13600" class="Symbol">:</a> <a id="13602" href="mi.MartinLof2006.html#13364" class="Bound">i</a> <a id="13604" href="Relation.Binary.html#2059" class="Field Operator">I.≈</a> <a id="13608" href="mi.MartinLof2006.html#13405" class="Bound">j</a>
              <a id="13624" href="mi.MartinLof2006.html#13596" class="Bound">i≈j</a> <a id="13628" class="Symbol">=</a> <a id="13630" href="mi.MartinLof2006.html#12700" class="Bound">p₃</a> <a id="13633" class="Symbol">(</a><a id="13634" href="mi.MartinLof2006.html#13395" class="Bound">y</a> <a id="13636" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13638" href="mi.MartinLof2006.html#13399" class="Bound">Aiy</a> <a id="13642" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13644" href="mi.MartinLof2006.html#13526" class="Bound">Ajy</a><a id="13647" class="Symbol">)</a>

              <a id="13664" href="mi.MartinLof2006.html#13664" class="Bound">fi≈fj</a> <a id="13670" class="Symbol">:</a> <a id="13672" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13674" href="mi.MartinLof2006.html#13364" class="Bound">i</a> <a id="13676" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="13680" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13682" href="mi.MartinLof2006.html#13405" class="Bound">j</a>
              <a id="13698" href="mi.MartinLof2006.html#13664" class="Bound">fi≈fj</a> <a id="13704" class="Symbol">=</a> <a id="13706" href="mi.MartinLof2006.html#12790" class="Bound">Ext[f]</a> <a id="13713" href="mi.MartinLof2006.html#13596" class="Bound">i≈j</a>

              <a id="13732" href="mi.MartinLof2006.html#13732" class="Bound">fi≈y</a> <a id="13737" class="Symbol">:</a> <a id="13739" href="mi.MartinLof2006.html#12738" class="Bound">f</a> <a id="13741" href="mi.MartinLof2006.html#13364" class="Bound">i</a> <a id="13743" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="13747" href="mi.MartinLof2006.html#13395" class="Bound">y</a>
              <a id="13763" href="mi.MartinLof2006.html#13732" class="Bound">fi≈y</a> <a id="13768" class="Symbol">=</a> <a id="13770" href="Relation.Binary.Core.html#7072" class="Function">S.trans</a> <a id="13778" href="mi.MartinLof2006.html#13664" class="Bound">fi≈fj</a> <a id="13784" href="mi.MartinLof2006.html#13409" class="Bound">fj≈y</a>
            <a id="13801" class="Keyword">in</a>
              <a id="13818" href="mi.MartinLof2006.html#13732" class="Bound">fi≈y</a> <a id="13823" class="Symbol">}</a>
        <a id="13833" class="Keyword">in</a>
          <a id="13846" href="mi.MartinLof2006.html#12860" class="Bound">S₁</a> <a id="13849" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13851" href="mi.MartinLof2006.html#12924" class="Bound">p₆</a> <a id="13854" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13856" href="mi.MartinLof2006.html#13307" class="Bound">p₇</a>
</pre>
<p>This, however, is not guaranteed by the constructive, or inten­sional, axiom of choice which follows from the strong rule of <span class="math inline">∃</span>-elimination in type theory. Thus our attempt to prove Zermelo’s axiom of choice has failed, as was to be expected.</p>
<p>On the other hand, we have succeeded in proving that Zermelo’s axiom of choice follows from the exten­sional axiom of choice</p>
<p><span class="math display">(∀i : I)(∃x : S)A_i(x) → (∃f : I → S)(\text{Ext}(f)\ \&amp;\ (∀i : I)A_i(f(i))),</span></p>
<p>which I shall call <span class="math inline">\text{ExtAC},</span> where</p>
<p><span class="math display">\text{Ext}(f) = (∀i, j: I)(i =_I j → f(i) =_S f(j)).</span></p>
<p>The only trouble with it is that it lacks the evidence of the inten­sional axiom of choice, which does not prevent one from investigating its consequences, of course.</p>
<h4 id="theorem-i.">Theorem I.</h4>
<p><em>The following are equivalent in constructive type theory:</em></p>
<ol type="i">
<li><em>The exten­sional axiom of choice.</em></li>
<li><em>Zermelo’s axiom of choice.</em></li>
<li><em>Epimorphisms split, that is, every surjective exten­sional function has an exten­sional right inverse.</em></li>
<li><em>Unique representatives can be picked from the equivalence classes of any given equivalence relation.</em></li>
</ol>
<p>Of these four equivalent statements, (iii) is the topos-theoretic axiom of choice, which is thus equivalent, not to the constructively valid type-theoretic axiom of choice, but to Zermelo’s axiom of choice.</p>
<h5 id="proof.">Proof.</h5>
<p>We shall prove the implications (i)<span class="math inline">→</span>(ii)<span class="math inline">→</span>(iii)<span class="math inline">→</span>(iv)<span class="math inline">→</span>(i) in this order.</p>
<h6 id="iii">(i)<span class="math inline">→</span>(ii)</h6>
<p>This is precisely the result of the considerations prior to the formulation of the theorem.</p>
<h6 id="iiiii">(ii)<span class="math inline">→</span>(iii)</h6>
<p>Let <span class="math inline">(S, =_S)</span> and <span class="math inline">(I, =_I)</span> be two exten­sional sets, and let <span class="math inline">f : S → I</span> be an exten­sional and surjective mapping between them. By definition, put</p>
<p><span class="math display">A_i = f^{-1}(i) = \{x\ |\ f(x) =_I i\}.</span></p>
<p>Then</p>
<ol type="1">
<li><span class="math inline">x =_S y → (A_i(x) ↔ A_i(y))</span></li>
</ol>
<p>by the assumed exten­sionality of <span class="math inline">f,</span></p>
<ol start="2" type="1">
<li><span class="math inline">i =_I j → (∀x : S)(A_i(x) ↔ A_j(x))</span></li>
</ol>
<p>since <span class="math inline">f(x) =_I i</span> is equivalent to <span class="math inline">f(x) =_I j</span> provided that <span class="math inline">i =_I j,</span></p>
<ol start="3" type="1">
<li><span class="math inline">(∃x : S)(A_i(x)\ \&amp;\ A_j(x)) → i =_I j</span></li>
</ol>
<p>since <span class="math inline">f(x) =_I i</span> and <span class="math inline">f(x) =_I j</span> together imply <span class="math inline">i =_I j,</span></p>
<ol start="4" type="1">
<li><span class="math inline">(∀x : S)(∃i : I)A_i(x)</span></li>
</ol>
<p>since <span class="math inline">A_{f(x)}(x)</span> for any <span class="math inline">x : S,</span> and</p>
<ol start="5" type="1">
<li><span class="math inline">(∀i : I)(∃x : S)A_i(x)</span></li>
</ol>
<p>by the assumed surjectivity of the function <span class="math inline">f.</span> Therefore we can apply Zermelo’s axiom of choice to get a subset <span class="math inline">S_1</span> of <span class="math inline">S</span> such that</p>
<p><span class="math display">(∀i : I)(∃!x : S)(A_i ∩ S_1)(x).</span></p>
<p>The constructive, or inten­sional, axiom of choice, to which we have access in type theory, then yields <span class="math inline">g : I → S</span> such that <span class="math inline">(A_i ∩ S_1)(g(i)),</span> that is,</p>
<p><span class="math display">(f(g(i)) =_I i)\ \&amp;\ S_1(g(i)),</span></p>
<p>so that <span class="math inline">g</span> is a right inverse of <span class="math inline">f,</span> and</p>
<p><span class="math display">(A_i ∩ S_1)(x) → g(i) =_S x.</span></p>
<p>It remains only to show that <span class="math inline">g</span> is exten­sional. So assume <span class="math inline">i, j : I.</span> Then we have</p>
<p><span class="math display">(A_i ∩ S_1)(g(i))</span></p>
<p>as well as</p>
<p><span class="math display">(A_j ∩ S_1)(g(j))</span></p>
<p>so that, if also <span class="math inline">i =_I j,</span></p>
<p><span class="math display">(A_i ∩ S_1)(g(j))</span></p>
<p>by the exten­sional dependence of <span class="math inline">A_i</span> on the index <span class="math inline">i.</span> The uniqueness property of <span class="math inline">A_i ∩ S_1</span> permits us to now conclude <span class="math inline">g(i) =_S g(j)</span> as desired.</p>
<h6 id="iiiiv.">(iii)<span class="math inline">→</span>(iv).</h6>
<p>Let <span class="math inline">I</span> be a set equipped with an equivalence relation <span class="math inline">=_I.</span> Then the identity function on <span class="math inline">I</span> is an exten­sional surjection from <span class="math inline">(I, \text{Id}_I)</span> to <span class="math inline">(I, =_I),</span> since any function is exten­sional with respect to the identity relation. Assuming that epimorphisms split, we can conclude that there exists a function <span class="math inline">g : I → I</span> such that</p>
<p><span class="math display">g(i) =_I i</span></p>
<p>and</p>
<p><span class="math display">i =_I j → \text{Id}_I(g(i), g(j)),</span></p>
<p>which is to say that <span class="math inline">g</span> has the miraculous property of picking a unique representative from each equivalence class of the given equivalence relation <span class="math inline">=_I.</span></p>
<h6 id="ivi.">(iv)<span class="math inline">→</span>(i).</h6>
<p>Let <span class="math inline">(I, =_I)</span> and <span class="math inline">(S, =_S)</span> be two sets, each equipped with an equivalence relation, and let <span class="math inline">(A_i)_{i : I}</span> be a family of exten­sional subsets of <span class="math inline">S,</span></p>
<p><span class="math display">x =_S y → (A_i(x) ↔ A_i(y)),</span></p>
<p>which depends exten­sionally on the index <span class="math inline">i,</span></p>
<p><span class="math display">i =_I j → (∀x : S)(A_i(x) ↔ A_j(x)).</span></p>
<p>Furthermore, assume that</p>
<p><span class="math display">(∀i : I)(∃x : S)A_i(x)</span></p>
<p>holds. By the inten­sional axiom of choice, valid in constructive type theory, we can conclude that there exists a choice function <span class="math inline">f : I → S</span> such that</p>
<p><span class="math display">(∀i : I)A_i(f(i)).</span></p>
<p>This choice function need not be exten­sional, of course, unless <span class="math inline">=_I</span> is the identity relation on the index set <span class="math inline">I.</span> But, applying the miraculous principle of picking a unique representative of each equivalence class to the equivalence relation <span class="math inline">=_I,</span> we get a function <span class="math inline">g : I → I</span> such that</p>
<p><span class="math display">g(i) =_I i</span></p>
<p>and</p>
<p><span class="math display">i =_I j → \text{Id}_I(g(i), g(j)).</span></p>
<p>Then <span class="math inline">f \circ g : I → S</span> becomes exten­sional,</p>
<p><span class="math display">
  i =_I j → \text{Id}_I(g(i), g(j)) → \underbrace{f(g(i))}_{(f \circ g)(i)}
    =_S \underbrace{f(g(j))}_{(f \circ g)(j)}.
</span></p>
<p>Moreover, from <span class="math inline">(∀i : I)</span><span class="math inline">A_i(f(i)),</span> it follows that</p>
<p><span class="math display">(∀i : I)A_{g(i)}(f(g(i))).</span></p>
<p>But</p>
<p><span class="math display">g(i) =_I i → (∀x : S)(A_{g(i)}(x) ↔ A_i(x)),</span></p>
<p>so that</p>
<p><span class="math display">(∀i : I)A_i(\underbrace{f(g(i))}_{(f \circ g)(i)}).</span></p>
<p>Hence <span class="math inline">f \circ g</span> has become an exten­sional choice function, which means that the exten­sional axiom of choice is satisfied.</p>
<p>Another indication that the exten­sional axiom of choice is the correct type-theoretic rendering of Zermelo’s axiom of choice comes from constructive set theory. Peter Aczel has shown how to interpret the language of Zermelo-Fraenkel set theory in constructive type theory, this interpretation being the natural constructive version of the cumulative hierarchy, and investigated what set-theoretical principles that become validated under that interpretation.<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> But one may also ask, conversely, what principle, or principles, that have to be adjoined to constructive type theory in order to validate a specific set-theoretical axiom. In particular, this may be asked about the formalized version of the axiom of choice that Zermelo made part of his own axiomatization of set theory. The answer is as follows.</p>
<h4 id="theorem-ii.">Theorem II.</h4>
<p><em>When constructive type theory is strengthened by the exten­sional axiom of choice, the set-theoretical axiom of choice becomes validated under the Aczel interpretation.</em></p>
<h5 id="proof.-1">Proof.</h5>
<p>The set-theoretical axiom of choice says that, for any two iterative sets <span class="math inline">α</span> and <span class="math inline">β</span> and any relation <span class="math inline">R</span> between iterative sets,</p>
<p><span class="math display">(∀x ∈ α)(∃y ∈ β)R(x, y) → (∃φ : α → β)(∀x ∈ α)R(x, φ(x)).</span></p>
<p>The Aczel interpretation of the left-hand member of this implication is</p>
<p><span class="math display">(∀x : ᾱ)(∃y : β̄)R(α̃(x), β̃(x)),</span></p>
<p>which yields</p>
<p><span class="math display">(∃f : ᾱ → β̄)(∀x : ᾱ)R(α̃(x), β̃(f (x)))</span></p>
<p>by the type-theoretic axiom of choice. Now, put</p>
<p><span class="math display">φ = \{⟨α̃(x), β̃(f(x))⟩\ |\ x : ᾱ\}</span></p>
<p>by definition. We need to prove that <span class="math inline">φ</span> is a function from <span class="math inline">α</span> to <span class="math inline">β</span> in the sense of constructive set theory, that is,</p>
<p><span class="math display">α̃(x) = α̃(x&#39;) → β̃(f(x)) = β̃(f(x&#39;)).</span></p>
<p>Define the equivalence relations</p>
<p><span class="math display">(x =_{ᾱ} x&#39;) = (α̃(x) = α̃(x&#39;))</span></p>
<p>and</p>
<p><span class="math display">(y =_{β̄} y&#39;) = (β̃(y) = β̃(y&#39;))</span></p>
<p>on <span class="math inline">ᾱ</span> and <span class="math inline">β̄,</span> respectively. By the exten­sional axiom of choice in type theory, the choice function <span class="math inline">f : ᾱ → β̄</span> can be taken to be exten­sional with respect to these two equivalence relations,</p>
<p><span class="math display">x =_{ᾱ} x&#39; → f(x) =_{β̄} f(x&#39;),</span></p>
<p>which ensures that <span class="math inline">φ,</span> defined as above, is a function from <span class="math inline">α</span> to <span class="math inline">β</span> in the sense of constructive set theory.</p>
<h4 id="corollary.">Corollary.</h4>
<p><em>When constructive type theory (including one universe and the <span class="math inline">W</span>-operation) is strengthened by the exten­sional axiom of choice, it interprets all of <span class="math inline">\text{ZFC}.</span></em></p>
<h5 id="proof.-2">Proof.</h5>
<p>We already know from Aczel that <span class="math inline">\text{ZF}</span> is equivalent to <span class="math inline">\text{CZF}</span> <span class="math inline">+</span> <span class="math inline">\text{EM}.</span><a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> Hence <span class="math inline">\text{ZFC}</span> is equivalent to <span class="math inline">\text{CZF}</span> <span class="math inline">+</span> <span class="math inline">\text{EM}</span> <span class="math inline">+</span> <span class="math inline">\text{AC}.</span> But, by Diaconescu’s theorem as transferred to constructive set theory by Goodman and Myhill, the law of excluded middle follows from the axiom of choice in the context of constructive set theory.<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> It thus suffices to interpret <span class="math inline">\text{CZF}</span> <span class="math inline">+</span> <span class="math inline">\text{AC}</span> in <span class="math inline">\text{CTT}</span> <span class="math inline">+</span> <span class="math inline">\text{ExtAC},</span> and this is precisely what the Aczel interpretation does, by the previous theorem.</p>
<p>Another way of reaching the same conclusion is to interchange the order of the last two steps in the proof just given, arguing instead that <span class="math inline">\text{ZFC}</span> <span class="math inline">=</span> <span class="math inline">\text{CZF}</span> <span class="math inline">+</span> <span class="math inline">\text{EM}</span> <span class="math inline">+</span> <span class="math inline">\text{AC}</span> is interpretable in <span class="math inline">\text{CTT}</span> <span class="math inline">+</span> <span class="math inline">\text{EM}</span> <span class="math inline">+</span> <span class="math inline">\text{ExtAC}</span> by the previous theorem, and then appealing to the type-theoretic version of Diaconescu’s theorem, according to which the law of excluded middle follows from the exten­sional axiom of choice in the context of constructive type theory.<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> The final conclusion is anyhow that <span class="math inline">\text{ZFC}</span> is interpretable in <span class="math inline">\text{CTT}</span> <span class="math inline">+</span> <span class="math inline">\text{ExtAC}.</span></p>
<p>When Zermelo’s axiom of choice is formulated in the context of constructive type theory instead of Zermelo-Fraenkel set theory, it appears as <span class="math inline">\text{ExtAC},</span> the exten­sional axiom of choice</p>
<p><span class="math display">(∀i : I)(∃x : S)A(i, x) → (∃f : I → S)(\text{Ext}(f)\ \&amp;\ (∀i : I)A(i, f(i))),</span></p>
<p>where</p>
<p><span class="math display">\text{Ext}(f) = (∀i, j : I)(i =_I j → f(i) =_S f(j)),</span></p>
<p>and it then becomes manifest what is the problem with it: it breaks the principle that you cannot get something from nothing. Even if the relation <span class="math inline">A(i, x)</span> is exten­sional with respect to its two arguments, the truth of the antecedent <span class="math inline">(∀i : I)</span><span class="math inline">(∃x : S)</span><span class="math inline">A(i, x),</span> which does guarantee the existence of a choice function <span class="math inline">f : I → S</span> satisfying <span class="math inline">(∀i : I)</span><span class="math inline">A(i, f(i)),</span> is not enough to guarantee the exten­sionality of the choice function, that is, the truth of <span class="math inline">\text{Ext}(f).</span> Thus the problem with Zermelo’s axiom of choice is not the existence of the choice function but its exten­sionality, and this is not visible within an exten­sional framework, like Zermelo-Fraenkel set theory, where all functions are by definition exten­sional.</p>
<pre class="Agda">      <a id="23524" class="Comment">-- axiom of unique choice</a>
      <a id="23556" href="mi.MartinLof2006.html#23556" class="Function">AC!</a> <a id="23560" class="Symbol">=</a> <a id="23562" class="Symbol">(∀</a> <a id="23565" href="mi.MartinLof2006.html#23565" class="Bound">i</a> <a id="23567" class="Symbol">→</a> <a id="23569" href="mi.MartinLof2006.html#810" class="Function">Σ![</a> <a id="23573" href="mi.MartinLof2006.html#23573" class="Bound">x</a> <a id="23575" href="mi.MartinLof2006.html#810" class="Function">∈</a> <a id="23577" href="Relation.Binary.html#2033" class="Field">S</a> <a id="23579" href="mi.MartinLof2006.html#810" class="Function">/</a> <a id="23581" href="Relation.Binary.html#2059" class="Field Operator">S._≈_</a> <a id="23587" href="mi.MartinLof2006.html#810" class="Function">]</a> <a id="23589" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="23591" href="mi.MartinLof2006.html#23565" class="Bound">i</a> <a id="23593" href="mi.MartinLof2006.html#23573" class="Bound">x</a><a id="23594" class="Symbol">)</a> <a id="23596" class="Symbol">→</a> <a id="23598" href="Data.Product.html#911" class="Function">Σ[</a> <a id="23601" href="mi.MartinLof2006.html#23601" class="Bound">f</a> <a id="23603" href="Data.Product.html#911" class="Function">∈</a> <a id="23605" class="Symbol">(</a><a id="23606" href="Relation.Binary.html#2033" class="Field">I</a> <a id="23608" class="Symbol">→</a> <a id="23610" href="Relation.Binary.html#2033" class="Field">S</a><a id="23611" class="Symbol">)</a> <a id="23613" href="Data.Product.html#911" class="Function">]</a> <a id="23615" href="mi.MartinLof2006.html#10074" class="Function">Ext</a> <a id="23619" href="mi.MartinLof2006.html#23601" class="Bound">f</a> <a id="23621" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="23623" class="Symbol">∀</a> <a id="23625" href="mi.MartinLof2006.html#23625" class="Bound">i</a> <a id="23627" class="Symbol">→</a> <a id="23629" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="23631" href="mi.MartinLof2006.html#23625" class="Bound">i</a> <a id="23633" class="Symbol">(</a><a id="23634" href="mi.MartinLof2006.html#23601" class="Bound">f</a> <a id="23636" href="mi.MartinLof2006.html#23625" class="Bound">i</a><a id="23637" class="Symbol">)</a>

      <a id="23646" href="mi.MartinLof2006.html#23646" class="Function">ac!</a> <a id="23650" class="Symbol">:</a> <a id="23652" href="mi.MartinLof2006.html#10325" class="Function">P₂</a> <a id="23655" class="Symbol">→</a> <a id="23657" href="mi.MartinLof2006.html#23556" class="Function">AC!</a>
      <a id="23667" href="mi.MartinLof2006.html#23646" class="Function">ac!</a> <a id="23671" href="mi.MartinLof2006.html#23671" class="Bound">p₂</a> <a id="23674" href="mi.MartinLof2006.html#23674" class="Bound">h</a> <a id="23676" class="Symbol">=</a>
        <a id="23686" class="Keyword">let</a>
          <a id="23700" href="mi.MartinLof2006.html#23700" class="Bound">z</a> <a id="23702" class="Symbol">:</a> <a id="23704" href="Data.Product.html#911" class="Function">Σ[</a> <a id="23707" href="mi.MartinLof2006.html#23707" class="Bound">f</a> <a id="23709" href="Data.Product.html#911" class="Function">∈</a> <a id="23711" class="Symbol">(</a><a id="23712" href="Relation.Binary.html#2033" class="Field">I</a> <a id="23714" class="Symbol">→</a> <a id="23716" href="Relation.Binary.html#2033" class="Field">S</a><a id="23717" class="Symbol">)</a> <a id="23719" href="Data.Product.html#911" class="Function">]</a> <a id="23721" class="Symbol">∀</a> <a id="23723" href="mi.MartinLof2006.html#23723" class="Bound">i</a> <a id="23725" class="Symbol">→</a> <a id="23727" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="23729" href="mi.MartinLof2006.html#23723" class="Bound">i</a> <a id="23731" class="Symbol">(</a><a id="23732" href="mi.MartinLof2006.html#23707" class="Bound">f</a> <a id="23734" href="mi.MartinLof2006.html#23723" class="Bound">i</a><a id="23735" class="Symbol">)</a> <a id="23737" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="23739" class="Symbol">(∀</a> <a id="23742" class="Symbol">{</a><a id="23743" href="mi.MartinLof2006.html#23743" class="Bound">y</a><a id="23744" class="Symbol">}</a> <a id="23746" class="Symbol">→</a> <a id="23748" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="23750" href="mi.MartinLof2006.html#23723" class="Bound">i</a> <a id="23752" href="mi.MartinLof2006.html#23743" class="Bound">y</a> <a id="23754" class="Symbol">→</a> <a id="23756" href="mi.MartinLof2006.html#23707" class="Bound">f</a> <a id="23758" href="mi.MartinLof2006.html#23723" class="Bound">i</a> <a id="23760" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="23764" href="mi.MartinLof2006.html#23743" class="Bound">y</a><a id="23765" class="Symbol">)</a>
          <a id="23777" href="mi.MartinLof2006.html#23700" class="Bound">z</a> <a id="23779" class="Symbol">=</a> <a id="23781" href="mi.MartinLof2006.html#5278" class="Function">ac</a> <a id="23784" href="mi.MartinLof2006.html#23674" class="Bound">h</a>

          <a id="23797" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="23799" class="Symbol">:</a> <a id="23801" href="Relation.Binary.html#2033" class="Field">I</a> <a id="23803" class="Symbol">→</a> <a id="23805" href="Relation.Binary.html#2033" class="Field">S</a>
          <a id="23817" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="23819" class="Symbol">=</a> <a id="23821" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="23827" href="mi.MartinLof2006.html#23700" class="Bound">z</a>

          <a id="23840" href="mi.MartinLof2006.html#23840" class="Bound">k→Ak[fk]</a> <a id="23849" class="Symbol">:</a> <a id="23851" class="Symbol">∀</a> <a id="23853" href="mi.MartinLof2006.html#23853" class="Bound">k</a> <a id="23855" class="Symbol">→</a> <a id="23857" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="23859" href="mi.MartinLof2006.html#23853" class="Bound">k</a> <a id="23861" class="Symbol">(</a><a id="23862" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="23864" href="mi.MartinLof2006.html#23853" class="Bound">k</a><a id="23865" class="Symbol">)</a>
          <a id="23877" href="mi.MartinLof2006.html#23840" class="Bound">k→Ak[fk]</a> <a id="23886" href="mi.MartinLof2006.html#23886" class="Bound">k</a> <a id="23888" class="Symbol">=</a> <a id="23890" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="23896" class="Symbol">(</a><a id="23897" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="23903" href="mi.MartinLof2006.html#23700" class="Bound">z</a> <a id="23905" href="mi.MartinLof2006.html#23886" class="Bound">k</a><a id="23906" class="Symbol">)</a>

          <a id="23919" href="mi.MartinLof2006.html#23919" class="Bound">Aky→fk≈y</a> <a id="23928" class="Symbol">:</a> <a id="23930" class="Symbol">∀</a> <a id="23932" class="Symbol">{</a><a id="23933" href="mi.MartinLof2006.html#23933" class="Bound">k</a> <a id="23935" href="mi.MartinLof2006.html#23935" class="Bound">y</a><a id="23936" class="Symbol">}</a> <a id="23938" class="Symbol">→</a> <a id="23940" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="23942" href="mi.MartinLof2006.html#23933" class="Bound">k</a> <a id="23944" href="mi.MartinLof2006.html#23935" class="Bound">y</a> <a id="23946" class="Symbol">→</a> <a id="23948" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="23950" href="mi.MartinLof2006.html#23933" class="Bound">k</a> <a id="23952" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="23956" href="mi.MartinLof2006.html#23935" class="Bound">y</a>
          <a id="23968" href="mi.MartinLof2006.html#23919" class="Bound">Aky→fk≈y</a> <a id="23977" class="Symbol">{</a><a id="23978" href="mi.MartinLof2006.html#23978" class="Bound">k</a><a id="23979" class="Symbol">}</a> <a id="23981" class="Symbol">=</a> <a id="23983" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="23989" class="Symbol">(</a><a id="23990" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="23996" href="mi.MartinLof2006.html#23700" class="Bound">z</a> <a id="23998" href="mi.MartinLof2006.html#23978" class="Bound">k</a><a id="23999" class="Symbol">)</a>

          <a id="24012" href="mi.MartinLof2006.html#24012" class="Bound">i≈j→fi≈fj</a> <a id="24022" class="Symbol">:</a> <a id="24024" class="Symbol">∀</a> <a id="24026" class="Symbol">{</a><a id="24027" href="mi.MartinLof2006.html#24027" class="Bound">i</a> <a id="24029" href="mi.MartinLof2006.html#24029" class="Bound">j</a><a id="24030" class="Symbol">}</a> <a id="24032" class="Symbol">→</a> <a id="24034" href="mi.MartinLof2006.html#24027" class="Bound">i</a> <a id="24036" href="Relation.Binary.html#2059" class="Field Operator">I.≈</a> <a id="24040" href="mi.MartinLof2006.html#24029" class="Bound">j</a> <a id="24042" class="Symbol">→</a> <a id="24044" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24046" href="mi.MartinLof2006.html#24027" class="Bound">i</a> <a id="24048" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="24052" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24054" href="mi.MartinLof2006.html#24029" class="Bound">j</a>
          <a id="24066" href="mi.MartinLof2006.html#24012" class="Bound">i≈j→fi≈fj</a> <a id="24076" class="Symbol">{</a><a id="24077" href="mi.MartinLof2006.html#24077" class="Bound">i</a><a id="24078" class="Symbol">}</a> <a id="24080" class="Symbol">{</a><a id="24081" href="mi.MartinLof2006.html#24081" class="Bound">j</a><a id="24082" class="Symbol">}</a> <a id="24084" href="mi.MartinLof2006.html#24084" class="Bound">i≈j</a> <a id="24088" class="Symbol">=</a>
            <a id="24102" class="Keyword">let</a>
              <a id="24120" href="mi.MartinLof2006.html#24120" class="Bound">Aj[fj]</a> <a id="24127" class="Symbol">:</a> <a id="24129" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="24131" href="mi.MartinLof2006.html#24081" class="Bound">j</a> <a id="24133" class="Symbol">(</a><a id="24134" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24136" href="mi.MartinLof2006.html#24081" class="Bound">j</a><a id="24137" class="Symbol">)</a>
              <a id="24153" href="mi.MartinLof2006.html#24120" class="Bound">Aj[fj]</a> <a id="24160" class="Symbol">=</a> <a id="24162" href="mi.MartinLof2006.html#23840" class="Bound">k→Ak[fk]</a> <a id="24171" href="mi.MartinLof2006.html#24081" class="Bound">j</a>

              <a id="24188" href="mi.MartinLof2006.html#24188" class="Bound">Ai[fj]</a> <a id="24195" class="Symbol">:</a> <a id="24197" href="mi.MartinLof2006.html#10165" class="Bound">A</a> <a id="24199" href="mi.MartinLof2006.html#24077" class="Bound">i</a> <a id="24201" class="Symbol">(</a><a id="24202" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24204" href="mi.MartinLof2006.html#24081" class="Bound">j</a><a id="24205" class="Symbol">)</a>
              <a id="24221" href="mi.MartinLof2006.html#24188" class="Bound">Ai[fj]</a> <a id="24228" class="Symbol">=</a> <a id="24230" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="24236" class="Symbol">(</a><a id="24237" href="mi.MartinLof2006.html#23671" class="Bound">p₂</a> <a id="24240" class="Symbol">(</a><a id="24241" href="Relation.Binary.Core.html#7046" class="Function">I.sym</a> <a id="24247" href="mi.MartinLof2006.html#24084" class="Bound">i≈j</a><a id="24250" class="Symbol">)</a> <a id="24252" class="Symbol">(</a><a id="24253" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24255" href="mi.MartinLof2006.html#24081" class="Bound">j</a><a id="24256" class="Symbol">))</a> <a id="24259" href="mi.MartinLof2006.html#24120" class="Bound">Aj[fj]</a>

              <a id="24281" href="mi.MartinLof2006.html#24281" class="Bound">fi≈fj</a> <a id="24287" class="Symbol">:</a> <a id="24289" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24291" href="mi.MartinLof2006.html#24077" class="Bound">i</a> <a id="24293" href="Relation.Binary.html#2059" class="Field Operator">S.≈</a> <a id="24297" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24299" href="mi.MartinLof2006.html#24081" class="Bound">j</a>
              <a id="24315" href="mi.MartinLof2006.html#24281" class="Bound">fi≈fj</a> <a id="24321" class="Symbol">=</a> <a id="24323" href="mi.MartinLof2006.html#23919" class="Bound">Aky→fk≈y</a> <a id="24332" href="mi.MartinLof2006.html#24188" class="Bound">Ai[fj]</a>
            <a id="24351" class="Keyword">in</a>
              <a id="24368" href="mi.MartinLof2006.html#24281" class="Bound">fi≈fj</a>
        <a id="24382" class="Keyword">in</a>
          <a id="24395" href="mi.MartinLof2006.html#23797" class="Bound">f</a> <a id="24397" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="24399" href="mi.MartinLof2006.html#24012" class="Bound">i≈j→fi≈fj</a> <a id="24409" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="24411" href="mi.MartinLof2006.html#23840" class="Bound">k→Ak[fk]</a>
</pre>
<p>If we want to ensure the exten­sionality of the choice function, the antecedent clause of the exten­sional axiom of choice has to be strengthened. The natural way of doing this is to replace <span class="math inline">\text{ExtAC}</span> by <span class="math inline">\text{AC!},</span> the axiom of unique choice, or no choice,</p>
<p><span class="math display">(∀i : I)(∃!x : S)A(i, x) → (∃f : I → S)(\text{Ext}(f)\ \&amp;\ (∀i : I)A(i, f(i))),</span></p>
<p>which is as valid as the inten­sional axiom of choice. Indeed, assume <span class="math inline">(∀i : I)</span><span class="math inline">(∃!x : S)</span><span class="math inline">A(i, x)</span> to be true. Then, by the inten­sional axiom of choice, there exists a choice function <span class="math inline">f : I → S</span> satisfying <span class="math inline">(∀i : I)</span><span class="math inline">A(i, f(i)).</span> Because of the uniqueness condition, such a function <span class="math inline">f : I → S</span> is necessarily exten­sional. For suppose that <span class="math inline">i, j : I</span> are such that <span class="math inline">i =_I j</span> is true. Then <span class="math inline">A(i, f(i))</span> and <span class="math inline">A(j, f(j))</span> are both true. Hence, by the exten­sionality of <span class="math inline">A(i, x)</span> in its first argument, so is <span class="math inline">A(i, f(j)).</span> The uniqueness condition now guarantees that <span class="math inline">f(i) =_S f(j),</span> that is, that <span class="math inline">f : I → S</span> is exten­sional. The axiom of unique choice <span class="math inline">\text{AC!}</span> may be considered as the valid form of exten­sional choice, as opposed to <span class="math inline">\text{ExtAC},</span> which lacks justification.</p>
<p>The inability to distinguish between the inten­sional and the exten­sional axiom of choice has led to one’s taking the need for the axiom of choice in proving that the union of a countable sequence of countable sets is again countable, that the real numbers, defined as Cauchy sequences of rational numbers, are Cauchy complete, etc., as a justification of Zermelo’s axiom of choice. As Zermelo himself wrote towards the end of the short paper in which he originally introduced the axiom of choice,</p>
<blockquote>
<p><span lang="de">Dieses logische Prinzip läßt sich zwar nicht auf ein noch einfacheres zurückführen, wird aber in der mathematischen Deduktion überall unbedenklich angewendet.</span><a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a></p>
</blockquote>
<p>What Zermelo wrote here about the omnipresent, and often subconscious, use of the axiom of choice in mathematical proofs is incontrovertible, but it concerns the constructive, or inten­sional, version of it, which follows almost immediately from the strong rule of existential elimination. It cannot be taken as a justification of his own version of the axiom of choice, including as it does the exten­sionality of the choice function.</p>
<p>Within an exten­sional foundational framework, like topos theory or constructive set theory, it is not wholly impossible to formulate a counterpart of the constructive axiom of choice, despite of its inten­sional character, but it becomes complicated. In topos theory, there is the axiom that there are enough projectives, which is to say that every object is the surjective image of a projective object, and, in constructive set theory, Aczel has introduced the analogous axiom that every set has a base.<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> Roughly speaking, this is to say that every set is the surjective image of a set for which the axiom of choice holds. The technical complication of these axioms speaks to my mind for an inten­sional foundational framework, like constructive type theory, in which the intuitive argument why the axiom of choice holds on the Brouwer-Heyting-Kolmogorov interpretation is readily formalized, and in which whatever exten­sional notions that are needed can be built up, in agreement with the title of Martin Hofmann’s thesis, <em>Exten­sional Constructs in Inten­sional Type Theory</em>.<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> Exten­sionality does not come for free.</p>
<p>Finally, since this is only a couple of weeks from the centenary of Zermelo’s first formulation of the axiom of choice, it may not be out of place to remember the crucial role it has played for the formalization of both Zermelo-Fraenkel set theory and constructive type theory. In the case of set theory, there was the need for Zermelo of putting his proof of the well-ordering theorem on a formally rigorous basis, whereas, in the case of type theory, there was the intuitively convincing argument which made axiom of choice evident on the constructive interpretation of the logical operations, an argument which nevertheless could not be faithfully formalized in any then existing formal system.</p>
<!-- ******************************************************************************************* -->
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>G. Cantor (1883) <a href="https://sci-hub.st/10.1007/BF01446819"><span lang="de">Über unendliche lineare Punktmannigfaltigkeiten. Nr. 5</span></a>, <em><span lang="de">Math. Annalen</span></em>, Vol. 21(4), pp. 545–591. Reprinted in <em><a href="https://sci-hub.st/10.1007/978-3-662-00274-2"><span lang="de">Gesammelte Abhandlungen</span></a></em>, Edited by E. Zermelo (1932), Springer-Verlag, Berlin, pp. 165–208. <!-- --><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>G. H. Moore (1982) <em><a href="https://sci-hub.st/10.1007/978-1-4613-9478-5">Zermelo’s Axiom of Choice: Its Origins, Development, and Influence</a></em>, Springer-Verlag, New York, p. 51. <!-- --><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>E. Zermelo (1904) <a href="https://sci-hub.st/10.1007/BF01445300"><span lang="de">Beweis, daß jede Menge wohlgeordnet werden kann. (Aus einem an Herrn Hilbert gerichteten Briefe.)</span></a>, <em><span lang="de">Math. Annalen</span></em>, Vol. 59(4), pp. 514–516. <!-- --><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>E. Zermelo (1908) <a href="https://sci-hub.st/10.1007/BF01450054"><span lang="de">Neuer Beweis für die Möglichkeit einer Wohlordnung</span></a>, <em><span lang="de">Math. Annalen</span></em>, Vol. 65(1), pp. 107–128. <!-- --><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>E. Zermelo (1908) <a href="https://sci-hub.st/10.1007/BF01449999"><span lang="de">Untersuchungen über die Grundlagen der Mengenlehre. I</span></a>, <em><span lang="de">Math. Annalen</span></em>, Vol. 65(2), pp. 261–281. <!-- --><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>G. H. Moore (1982), <a href="#fn2">op. cit.</a>, pp. 92–137. <!-- --><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>M. Zorn (1935) <a href="https://sci-hub.st/10.1090/S0002-9904-1935-06166-X">A remark on method in transfinite algebra</a>, <em>Bull. Amer. Math. Soc.</em>, Vol. 41(10), pp. 667–670. <!-- --><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>R. Baire, É. Borel, J. Hadamard and H. Lebesgue (1905) <a href="http://www.numdam.org/item/10.24033/bsmf.761.pdf"><span lang="fr">Cinq lettres sur la théorie des ensembles</span></a>, <em><span lang="fr">Bull. Soc. Math. France</span></em>, Vol. 33(17), pp. 261–273. <!-- TODO: DOI not on sci-hub; https://doi.org/10.24033/bsmf.761 --><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>É. Borel (1905) <a href="https://sci-hub.st/10.1007/BF01677266"><span lang="fr">Quelques remarques sur les principes de la théorie des ensembles</span></a>, <em><span lang="de">Math. Annalen</span></em>, Vol. 60(2), pp. 194–195. <!-- --><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>L. E. J. Brouwer (1907) <em><a href="https://eprints.illc.uva.nl/id/eprint/1852/2/HDS-20-LEJBrouwer.text.pdf"><span lang="nl">Over de Grondslagen der Wiskunde</span></a></em>, Maas &amp; van Suchtelen, Amsterdam. English translation in <em><a href="https://library.lol/main/0CFBA75A5C78E49F96114337B2B8790D">Collected Works, Vol. 1</a></em>, Edited by A. Heyting (1975), North–Holland, Amsterdam, pp. 11–101. <!-- TODO: both DOIs missing --><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>E. Bishop (1967) <em><a href="https://library.lol/main/D69762DE514CE40FAA389C6F178F66D4">Foundations of Constructive Analysis</a></em>, McGraw-Hill, New York, p. 9. <!-- TODO: DOI missing --><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>R. Diaconescu (1975) <a href="https://sci-hub.st/10.1090/S0002-9939-1975-0373893-X">Axiom of choice and complementation</a>, <em>Proc. Amer. Math. Soc.</em>, Vol. 51(1), pp. 176–178. <!-- --><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>E. Zermelo (1904), <a href="#fn3">op. cit.</a>, footnote 3, p. 514. <!-- --><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>E. Zermelo (1908), <a href="#fn4">op. cit.</a>, footnote 4, p. 110. <!-- --><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>A. N. Whitehead (1902) <a href="https://sci-hub.st/10.2307/2370026">On cardinal numbers</a>, <em>Amer. J. Math.</em>, Vol. 24(4), pp. 367–394. <!-- --><a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>B. Russell (1906) <a href="https://sci-hub.st/10.1112/plms/s2-4.1.29">On some difficulties in the theory of transfinite numbers and order types</a>, <em>Proc. London Math. Soc.</em>, Ser. 2, Vol. 4(1), pp. 29–53. <!-- --><a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>P. Aczel (1978) <a href="mi.Aczel1978.html" class="mi">The type theoretic interpretation of constructive set theory</a>, <em>Logic Colloquium ’77</em>, Edited by A. Macintyre, L. Pacholski, and J. Paris, North Holland, Amsterdam, pp. 55–66. <!-- --><a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>P. Aczel (1978), <a href="#fn17">op. cit.</a>, p. 59. <!-- --><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>N. D. Goodman and J. Myhill (1978) <a href="https://sci-hub.st/10.1002/malq.19780242514">Choice implies excluded middle</a>, <em><span lang="de">Zeitschrift für math. Logik und Grundlagen der Math.</span></em>, Vol. 24(25–30), p. 461. <!-- --><a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>S. Lacas and B. Werner (1999) <del>Which choices imply the excluded middle? About Diaconescu’s trick in type theory</del>, Unpublished, pp. 9–10. I am indebted to Jesper Carlström for providing me with this reference. <!-- TODO: document missing --><a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>E. Zermelo (1904), <a href="#fn3">op. cit.</a>, footnote 3, p. 516. <!-- --><a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>P. Aczel (1982) <a href="https://sci-hub.st/10.1016/S0049-237X(09)70120-X">The type theoretic interpretation of constructive set theory: Choice principles</a>, <em>L. E. J. Brouwer Centenary Symposium</em>, Edited by A. S. Troelstra and D. van Dalen, North Holland, Amsterdam, 1982, pp. 1–40. <!-- --><a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>M. Hofmann (1997) <em><a href="https://sci-hub.st/10.1007/978-1-4471-0963-1">Exten­sional Constructs in Inten­sional Type Theory</a></em>, Springer-Verlag, London. <!-- --><a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<div id="card">
<hr>
  <p>P. Martin-Löf (2006)</p>
  <p><a href="https://sci-hub.st/10.1093/comjnl/bxh162">100 years of Zermelo’s axiom of choice: What was the problem with it?</a></p>
  <p><em>Comp. J.</em>, Vol. 49(3), pp. 345–350.</p>
</div>
</main>
<nav id="foot">
<p><a href="mi.index.html">Mechanised Intuitionist</a></p>
</nav>
<script>
getRandomAngle = function (min, max) {
  const angle = min + Math.random() * (max - min);
  const sign = Math.random() < 0.5 ? -1 : 1;
  console.log(min, max, angle * sign);
  return angle * sign;
}
addEventListener('load', function () {
    const card = document.getElementById('card');
    if (card) {
      card.style.transform = 'rotate(' + getRandomAngle(1, 4) + 'deg)';
      const hr = card.children[0];
      if (hr) {
        hr.style.transform = 'rotate(' + getRandomAngle(8, 24) + 'deg)';
      }
    }
  });
</script>
</body>
</html>
