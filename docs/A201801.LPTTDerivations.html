<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>A201801.LPTTDerivations</title><link rel="stylesheet" href="AgdaPP.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="A201801.LPTTDerivations.html" class="Module">A201801.LPTTDerivations</a> <a id="32" class="Keyword">where</a>

<a id="39" class="Keyword">open</a> <a id="44" class="Keyword">import</a> <a id="51" href="A201801.Prelude.html" class="Module">A201801.Prelude</a>
<a id="67" class="Keyword">open</a> <a id="72" class="Keyword">import</a> <a id="79" href="A201801.Category.html" class="Module">A201801.Category</a>
<a id="96" class="Keyword">open</a> <a id="101" class="Keyword">import</a> <a id="108" href="A201801.Fin.html" class="Module">A201801.Fin</a>
<a id="120" class="Keyword">open</a> <a id="125" class="Keyword">import</a> <a id="132" href="A201801.Vec.html" class="Module">A201801.Vec</a>
<a id="144" class="Keyword">open</a> <a id="149" class="Keyword">import</a> <a id="156" href="A201801.VecLemmas.html" class="Module">A201801.VecLemmas</a>
<a id="174" class="Keyword">open</a> <a id="179" class="Keyword">import</a> <a id="186" href="A201801.AllVec.html" class="Module">A201801.AllVec</a>
<a id="201" class="Keyword">open</a> <a id="206" class="Keyword">import</a> <a id="213" href="A201801.S4TTTerms.html" class="Module">A201801.S4TTTerms</a>
<a id="231" class="Keyword">open</a> <a id="236" class="Keyword">import</a> <a id="243" href="A201801.S4TTTermsLemmas.html" class="Module">A201801.S4TTTermsLemmas</a>
<a id="267" class="Keyword">open</a> <a id="272" class="Keyword">import</a> <a id="279" href="A201801.LPTTTypes.html" class="Module">A201801.LPTTTypes</a>
<a id="297" class="Keyword">open</a> <a id="302" class="Keyword">import</a> <a id="309" href="A201801.LPTTTypesLemmas.html" class="Module">A201801.LPTTTypesLemmas</a>
<a id="333" class="Keyword">open</a> <a id="338" class="Keyword">import</a> <a id="345" href="A201801.LPTTAsserts.html" class="Module">A201801.LPTTAsserts</a>


<a id="367" class="Comment">--------------------------------------------------------------------------------</a>


<a id="450" class="Keyword">infix</a> <a id="456" class="Number">3</a> <a id="458" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">_⊢_⦂_valid[_]</a>
<a id="472" class="Keyword">data</a> <a id="_⊢_⦂_valid[_]"></a><a id="477" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">_⊢_⦂_valid[_]</a> <a id="491" class="Symbol">:</a> <a id="493" class="Symbol">∀</a> <a id="495" class="Symbol">{</a><a id="496" href="A201801.LPTTDerivations.html#496" class="Bound">d</a> <a id="498" href="A201801.LPTTDerivations.html#498" class="Bound">g</a><a id="499" class="Symbol">}</a> <a id="501" class="Symbol">→</a> <a id="503" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="511" href="A201801.LPTTDerivations.html#496" class="Bound">d</a> <a id="513" class="Symbol">→</a> <a id="515" href="A201801.S4TTTerms.html#258" class="Datatype">Term</a> <a id="520" href="A201801.LPTTDerivations.html#496" class="Bound">d</a> <a id="522" href="A201801.LPTTDerivations.html#498" class="Bound">g</a> <a id="524" class="Symbol">→</a> <a id="526" href="A201801.LPTTTypes.html#367" class="Datatype">Type</a> <a id="531" href="A201801.LPTTDerivations.html#496" class="Bound">d</a> <a id="533" class="Symbol">→</a> <a id="535" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="541" href="A201801.LPTTDerivations.html#496" class="Bound">d</a> <a id="543" href="A201801.LPTTDerivations.html#498" class="Bound">g</a> <a id="545" class="Symbol">→</a> <a id="547" class="PrimitiveType">Set</a>
  <a id="553" class="Keyword">where</a>
    <a id="_⊢_⦂_valid[_].var"></a><a id="563" href="A201801.LPTTDerivations.html#563" class="InductiveConstructor">var</a> <a id="567" class="Symbol">:</a> <a id="569" class="Symbol">∀</a> <a id="571" class="Symbol">{</a><a id="572" href="A201801.LPTTDerivations.html#572" class="Bound">d</a> <a id="574" href="A201801.LPTTDerivations.html#574" class="Bound">g</a> <a id="576" href="A201801.LPTTDerivations.html#576" class="Bound">I</a> <a id="578" href="A201801.LPTTDerivations.html#578" class="Bound">A</a><a id="579" class="Symbol">}</a> <a id="581" class="Symbol">→</a> <a id="583" class="Symbol">{</a><a id="584" href="A201801.LPTTDerivations.html#584" class="Bound">Δ</a> <a id="586" class="Symbol">:</a> <a id="588" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="596" href="A201801.LPTTDerivations.html#572" class="Bound">d</a><a id="597" class="Symbol">}</a> <a id="599" class="Symbol">{</a><a id="600" href="A201801.LPTTDerivations.html#600" class="Bound">Γ</a> <a id="602" class="Symbol">:</a> <a id="604" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="610" href="A201801.LPTTDerivations.html#572" class="Bound">d</a> <a id="612" href="A201801.LPTTDerivations.html#574" class="Bound">g</a><a id="613" class="Symbol">}</a>
                      <a id="637" class="Symbol">→</a> <a id="639" href="A201801.LPTTDerivations.html#600" class="Bound">Γ</a> <a id="641" href="A201801.Vec.html#2295" class="Datatype Operator">∋⟨</a> <a id="644" href="A201801.LPTTDerivations.html#576" class="Bound">I</a> <a id="646" href="A201801.Vec.html#2295" class="Datatype Operator">⟩</a> <a id="648" href="A201801.LPTTDerivations.html#578" class="Bound">A</a>
                      <a id="672" class="Symbol">→</a> <a id="674" href="A201801.LPTTDerivations.html#584" class="Bound">Δ</a> <a id="676" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="678" href="A201801.S4TTTerms.html#293" class="InductiveConstructor">VAR</a> <a id="682" href="A201801.LPTTDerivations.html#576" class="Bound">I</a> <a id="684" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="686" href="A201801.LPTTDerivations.html#578" class="Bound">A</a> <a id="688" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="695" href="A201801.LPTTDerivations.html#600" class="Bound">Γ</a> <a id="697" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>

    <a id="_⊢_⦂_valid[_].lam"></a><a id="704" href="A201801.LPTTDerivations.html#704" class="InductiveConstructor">lam</a> <a id="708" class="Symbol">:</a> <a id="710" class="Symbol">∀</a> <a id="712" class="Symbol">{</a><a id="713" href="A201801.LPTTDerivations.html#713" class="Bound">d</a> <a id="715" href="A201801.LPTTDerivations.html#715" class="Bound">g</a> <a id="717" href="A201801.LPTTDerivations.html#717" class="Bound">M</a> <a id="719" href="A201801.LPTTDerivations.html#719" class="Bound">A</a> <a id="721" href="A201801.LPTTDerivations.html#721" class="Bound">B</a><a id="722" class="Symbol">}</a> <a id="724" class="Symbol">→</a> <a id="726" class="Symbol">{</a><a id="727" href="A201801.LPTTDerivations.html#727" class="Bound">Δ</a> <a id="729" class="Symbol">:</a> <a id="731" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="739" href="A201801.LPTTDerivations.html#713" class="Bound">d</a><a id="740" class="Symbol">}</a> <a id="742" class="Symbol">{</a><a id="743" href="A201801.LPTTDerivations.html#743" class="Bound">Γ</a> <a id="745" class="Symbol">:</a> <a id="747" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="753" href="A201801.LPTTDerivations.html#713" class="Bound">d</a> <a id="755" href="A201801.LPTTDerivations.html#715" class="Bound">g</a><a id="756" class="Symbol">}</a>
                        <a id="782" class="Symbol">→</a> <a id="784" href="A201801.LPTTDerivations.html#727" class="Bound">Δ</a> <a id="786" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="788" href="A201801.LPTTDerivations.html#717" class="Bound">M</a> <a id="790" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="792" href="A201801.LPTTDerivations.html#721" class="Bound">B</a> <a id="794" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="801" href="A201801.LPTTDerivations.html#743" class="Bound">Γ</a> <a id="803" href="A201801.Vec.html#287" class="InductiveConstructor Operator">,</a> <a id="805" href="A201801.LPTTDerivations.html#719" class="Bound">A</a> <a id="807" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>
                        <a id="833" class="Symbol">→</a> <a id="835" href="A201801.LPTTDerivations.html#727" class="Bound">Δ</a> <a id="837" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="839" href="A201801.S4TTTerms.html#333" class="InductiveConstructor">LAM</a> <a id="843" href="A201801.LPTTDerivations.html#717" class="Bound">M</a> <a id="845" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="847" href="A201801.LPTTDerivations.html#719" class="Bound">A</a> <a id="849" href="A201801.LPTTTypes.html#431" class="InductiveConstructor Operator">⊃</a> <a id="851" href="A201801.LPTTDerivations.html#721" class="Bound">B</a> <a id="853" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="860" href="A201801.LPTTDerivations.html#743" class="Bound">Γ</a> <a id="862" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>

    <a id="_⊢_⦂_valid[_].app"></a><a id="869" href="A201801.LPTTDerivations.html#869" class="InductiveConstructor">app</a> <a id="873" class="Symbol">:</a> <a id="875" class="Symbol">∀</a> <a id="877" class="Symbol">{</a><a id="878" href="A201801.LPTTDerivations.html#878" class="Bound">d</a> <a id="880" href="A201801.LPTTDerivations.html#880" class="Bound">g</a> <a id="882" href="A201801.LPTTDerivations.html#882" class="Bound">M</a> <a id="884" href="A201801.LPTTDerivations.html#884" class="Bound">N</a> <a id="886" href="A201801.LPTTDerivations.html#886" class="Bound">A</a> <a id="888" href="A201801.LPTTDerivations.html#888" class="Bound">B</a><a id="889" class="Symbol">}</a> <a id="891" class="Symbol">→</a> <a id="893" class="Symbol">{</a><a id="894" href="A201801.LPTTDerivations.html#894" class="Bound">Δ</a> <a id="896" class="Symbol">:</a> <a id="898" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="906" href="A201801.LPTTDerivations.html#878" class="Bound">d</a><a id="907" class="Symbol">}</a> <a id="909" class="Symbol">{</a><a id="910" href="A201801.LPTTDerivations.html#910" class="Bound">Γ</a> <a id="912" class="Symbol">:</a> <a id="914" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="920" href="A201801.LPTTDerivations.html#878" class="Bound">d</a> <a id="922" href="A201801.LPTTDerivations.html#880" class="Bound">g</a><a id="923" class="Symbol">}</a>
                          <a id="951" class="Symbol">→</a> <a id="953" href="A201801.LPTTDerivations.html#894" class="Bound">Δ</a> <a id="955" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="957" href="A201801.LPTTDerivations.html#882" class="Bound">M</a> <a id="959" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="961" href="A201801.LPTTDerivations.html#886" class="Bound">A</a> <a id="963" href="A201801.LPTTTypes.html#431" class="InductiveConstructor Operator">⊃</a> <a id="965" href="A201801.LPTTDerivations.html#888" class="Bound">B</a> <a id="967" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="974" href="A201801.LPTTDerivations.html#910" class="Bound">Γ</a> <a id="976" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a> <a id="978" class="Symbol">→</a> <a id="980" href="A201801.LPTTDerivations.html#894" class="Bound">Δ</a> <a id="982" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="984" href="A201801.LPTTDerivations.html#884" class="Bound">N</a> <a id="986" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="988" href="A201801.LPTTDerivations.html#886" class="Bound">A</a> <a id="990" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="997" href="A201801.LPTTDerivations.html#910" class="Bound">Γ</a> <a id="999" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>
                          <a id="1027" class="Symbol">→</a> <a id="1029" href="A201801.LPTTDerivations.html#894" class="Bound">Δ</a> <a id="1031" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1033" href="A201801.S4TTTerms.html#382" class="InductiveConstructor">APP</a> <a id="1037" href="A201801.LPTTDerivations.html#882" class="Bound">M</a> <a id="1039" href="A201801.LPTTDerivations.html#884" class="Bound">N</a> <a id="1041" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1043" href="A201801.LPTTDerivations.html#888" class="Bound">B</a> <a id="1045" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1052" href="A201801.LPTTDerivations.html#910" class="Bound">Γ</a> <a id="1054" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>

    <a id="_⊢_⦂_valid[_].mvar"></a><a id="1061" href="A201801.LPTTDerivations.html#1061" class="InductiveConstructor">mvar</a> <a id="1066" class="Symbol">:</a> <a id="1068" class="Symbol">∀</a> <a id="1070" class="Symbol">{</a><a id="1071" href="A201801.LPTTDerivations.html#1071" class="Bound">d</a> <a id="1073" href="A201801.LPTTDerivations.html#1073" class="Bound">g</a> <a id="1075" href="A201801.LPTTDerivations.html#1075" class="Bound">I</a> <a id="1077" href="A201801.LPTTDerivations.html#1077" class="Bound">M</a> <a id="1079" href="A201801.LPTTDerivations.html#1079" class="Bound">A</a><a id="1080" class="Symbol">}</a> <a id="1082" class="Symbol">→</a> <a id="1084" class="Symbol">{</a><a id="1085" href="A201801.LPTTDerivations.html#1085" class="Bound">Δ</a> <a id="1087" class="Symbol">:</a> <a id="1089" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="1097" href="A201801.LPTTDerivations.html#1071" class="Bound">d</a><a id="1098" class="Symbol">}</a> <a id="1100" class="Symbol">{</a><a id="1101" href="A201801.LPTTDerivations.html#1101" class="Bound">Γ</a> <a id="1103" class="Symbol">:</a> <a id="1105" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="1111" href="A201801.LPTTDerivations.html#1071" class="Bound">d</a> <a id="1113" href="A201801.LPTTDerivations.html#1073" class="Bound">g</a><a id="1114" class="Symbol">}</a>
                         <a id="1141" class="Symbol">→</a> <a id="1143" href="A201801.LPTTDerivations.html#1085" class="Bound">Δ</a> <a id="1145" href="A201801.LPTTAsserts.html#2010" class="Datatype Operator">∋◆⟨</a> <a id="1149" href="A201801.LPTTDerivations.html#1075" class="Bound">I</a> <a id="1151" href="A201801.LPTTAsserts.html#2010" class="Datatype Operator">⟩</a> <a id="1153" href="A201801.LPTTAsserts.html#471" class="InductiveConstructor Operator">⟪⊫</a> <a id="1156" href="A201801.LPTTDerivations.html#1077" class="Bound">M</a> <a id="1158" href="A201801.LPTTAsserts.html#471" class="InductiveConstructor Operator">⦂</a> <a id="1160" href="A201801.LPTTDerivations.html#1079" class="Bound">A</a> <a id="1162" href="A201801.LPTTAsserts.html#471" class="InductiveConstructor Operator">⟫</a>  <a id="1165" class="Comment">-- NOTE: This is more than Artemov-Bonelli</a>
                         <a id="1233" class="Symbol">→</a> <a id="1235" href="A201801.LPTTDerivations.html#1085" class="Bound">Δ</a> <a id="1237" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1239" href="A201801.S4TTTerms.html#436" class="InductiveConstructor">MVAR</a> <a id="1244" href="A201801.LPTTDerivations.html#1075" class="Bound">I</a> <a id="1246" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1248" href="A201801.LPTTDerivations.html#1079" class="Bound">A</a> <a id="1250" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1257" href="A201801.LPTTDerivations.html#1101" class="Bound">Γ</a> <a id="1259" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>

    <a id="_⊢_⦂_valid[_].box"></a><a id="1266" href="A201801.LPTTDerivations.html#1266" class="InductiveConstructor">box</a> <a id="1270" class="Symbol">:</a> <a id="1272" class="Symbol">∀</a> <a id="1274" class="Symbol">{</a><a id="1275" href="A201801.LPTTDerivations.html#1275" class="Bound">d</a> <a id="1277" href="A201801.LPTTDerivations.html#1277" class="Bound">g</a> <a id="1279" href="A201801.LPTTDerivations.html#1279" class="Bound">M</a> <a id="1281" href="A201801.LPTTDerivations.html#1281" class="Bound">A</a><a id="1282" class="Symbol">}</a> <a id="1284" class="Symbol">→</a> <a id="1286" class="Symbol">{</a><a id="1287" href="A201801.LPTTDerivations.html#1287" class="Bound">Δ</a> <a id="1289" class="Symbol">:</a> <a id="1291" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="1299" href="A201801.LPTTDerivations.html#1275" class="Bound">d</a><a id="1300" class="Symbol">}</a> <a id="1302" class="Symbol">{</a><a id="1303" href="A201801.LPTTDerivations.html#1303" class="Bound">Γ</a> <a id="1305" class="Symbol">:</a> <a id="1307" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="1313" href="A201801.LPTTDerivations.html#1275" class="Bound">d</a> <a id="1315" href="A201801.LPTTDerivations.html#1277" class="Bound">g</a><a id="1316" class="Symbol">}</a>
                      <a id="1340" class="Symbol">→</a> <a id="1342" href="A201801.LPTTDerivations.html#1287" class="Bound">Δ</a> <a id="1344" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1346" href="A201801.LPTTDerivations.html#1279" class="Bound">M</a> <a id="1348" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1350" href="A201801.LPTTDerivations.html#1281" class="Bound">A</a> <a id="1352" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1359" href="A201801.Vec.html#266" class="InductiveConstructor">∙</a> <a id="1361" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>
                      <a id="1385" class="Symbol">→</a> <a id="1387" href="A201801.LPTTDerivations.html#1287" class="Bound">Δ</a> <a id="1389" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1391" href="A201801.S4TTTerms.html#476" class="InductiveConstructor">BOX</a> <a id="1395" href="A201801.LPTTDerivations.html#1279" class="Bound">M</a> <a id="1397" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1399" href="A201801.LPTTTypes.html#475" class="InductiveConstructor Operator">[</a> <a id="1401" href="A201801.LPTTDerivations.html#1279" class="Bound">M</a> <a id="1403" href="A201801.LPTTTypes.html#475" class="InductiveConstructor Operator">]</a> <a id="1405" href="A201801.LPTTDerivations.html#1281" class="Bound">A</a> <a id="1407" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1414" href="A201801.LPTTDerivations.html#1303" class="Bound">Γ</a> <a id="1416" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>

    <a id="_⊢_⦂_valid[_].letbox"></a><a id="1423" href="A201801.LPTTDerivations.html#1423" class="InductiveConstructor">letbox</a> <a id="1430" class="Symbol">:</a> <a id="1432" class="Symbol">∀</a> <a id="1434" class="Symbol">{</a><a id="1435" href="A201801.LPTTDerivations.html#1435" class="Bound">d</a> <a id="1437" href="A201801.LPTTDerivations.html#1437" class="Bound">g</a> <a id="1439" href="A201801.LPTTDerivations.html#1439" class="Bound">M</a> <a id="1441" href="A201801.LPTTDerivations.html#1441" class="Bound">N</a> <a id="1443" href="A201801.LPTTDerivations.html#1443" class="Bound">Q</a> <a id="1445" href="A201801.LPTTDerivations.html#1445" class="Bound">A</a> <a id="1447" href="A201801.LPTTDerivations.html#1447" class="Bound">B</a><a id="1448" class="Symbol">}</a> <a id="1450" class="Symbol">→</a> <a id="1452" class="Symbol">{</a><a id="1453" href="A201801.LPTTDerivations.html#1453" class="Bound">Δ</a> <a id="1455" class="Symbol">:</a> <a id="1457" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="1465" href="A201801.LPTTDerivations.html#1435" class="Bound">d</a><a id="1466" class="Symbol">}</a> <a id="1468" class="Symbol">{</a><a id="1469" href="A201801.LPTTDerivations.html#1469" class="Bound">Γ</a> <a id="1471" class="Symbol">:</a> <a id="1473" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="1479" href="A201801.LPTTDerivations.html#1435" class="Bound">d</a> <a id="1481" href="A201801.LPTTDerivations.html#1437" class="Bound">g</a><a id="1482" class="Symbol">}</a>
                                  <a id="1518" class="Symbol">{</a><a id="1519" href="A201801.LPTTDerivations.html#1519" class="Bound">B′</a> <a id="1522" class="Symbol">:</a> <a id="1524" href="A201801.LPTTTypes.html#367" class="Datatype">Type</a> <a id="1529" href="A201801.LPTTDerivations.html#1435" class="Bound">d</a><a id="1530" class="Symbol">}</a> <a id="1532" class="Symbol">{{</a><a id="1534" href="A201801.LPTTDerivations.html#1534" class="Bound">p</a> <a id="1536" class="Symbol">:</a> <a id="1538" href="A201801.LPTTTypes.html#1779" class="Function">TMCUT</a> <a id="1544" href="A201801.LPTTDerivations.html#1443" class="Bound">Q</a> <a id="1546" href="A201801.LPTTDerivations.html#1447" class="Bound">B</a> <a id="1548" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1550" href="A201801.LPTTDerivations.html#1519" class="Bound">B′</a><a id="1552" class="Symbol">}}</a>
                               <a id="1586" class="Symbol">→</a> <a id="1588" href="A201801.LPTTDerivations.html#1453" class="Bound">Δ</a> <a id="1590" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1592" href="A201801.LPTTDerivations.html#1439" class="Bound">M</a> <a id="1594" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1596" href="A201801.LPTTTypes.html#475" class="InductiveConstructor Operator">[</a> <a id="1598" href="A201801.LPTTDerivations.html#1443" class="Bound">Q</a> <a id="1600" href="A201801.LPTTTypes.html#475" class="InductiveConstructor Operator">]</a> <a id="1602" href="A201801.LPTTDerivations.html#1445" class="Bound">A</a> <a id="1604" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1611" href="A201801.LPTTDerivations.html#1469" class="Bound">Γ</a> <a id="1613" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a> <a id="1615" class="Symbol">→</a> <a id="1617" href="A201801.LPTTDerivations.html#1453" class="Bound">Δ</a> <a id="1619" href="A201801.LPTTAsserts.html#588" class="InductiveConstructor Operator">,</a> <a id="1621" href="A201801.LPTTAsserts.html#471" class="InductiveConstructor Operator">⟪⊫</a> <a id="1624" href="A201801.LPTTDerivations.html#1443" class="Bound">Q</a> <a id="1626" href="A201801.LPTTAsserts.html#471" class="InductiveConstructor Operator">⦂</a> <a id="1628" href="A201801.LPTTDerivations.html#1445" class="Bound">A</a> <a id="1630" href="A201801.LPTTAsserts.html#471" class="InductiveConstructor Operator">⟫</a> <a id="1632" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1634" href="A201801.LPTTDerivations.html#1441" class="Bound">N</a> <a id="1636" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1638" href="A201801.LPTTDerivations.html#1447" class="Bound">B</a> <a id="1640" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1647" href="A201801.LPTTTypes.html#1239" class="Function">TMWKS</a> <a id="1653" href="A201801.LPTTDerivations.html#1469" class="Bound">Γ</a> <a id="1655" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>  <a id="1658" class="Comment">-- NOTE</a>
                               <a id="1697" class="Symbol">→</a> <a id="1699" href="A201801.LPTTDerivations.html#1453" class="Bound">Δ</a> <a id="1701" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1703" href="A201801.S4TTTerms.html#522" class="InductiveConstructor">LETBOX</a> <a id="1710" href="A201801.LPTTDerivations.html#1439" class="Bound">M</a> <a id="1712" href="A201801.LPTTDerivations.html#1441" class="Bound">N</a> <a id="1714" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1716" href="A201801.LPTTDerivations.html#1519" class="Bound">B′</a> <a id="1719" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1726" href="A201801.LPTTDerivations.html#1469" class="Bound">Γ</a> <a id="1728" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a>


<a id="1732" class="Keyword">infix</a> <a id="1738" class="Number">3</a> <a id="1740" href="A201801.LPTTDerivations.html#1757" class="Function Operator">_⊢_⦂_allvalid[_]</a>
<a id="_⊢_⦂_allvalid[_]"></a><a id="1757" href="A201801.LPTTDerivations.html#1757" class="Function Operator">_⊢_⦂_allvalid[_]</a> <a id="1774" class="Symbol">:</a> <a id="1776" class="Symbol">∀</a> <a id="1778" class="Symbol">{</a><a id="1779" href="A201801.LPTTDerivations.html#1779" class="Bound">d</a> <a id="1781" href="A201801.LPTTDerivations.html#1781" class="Bound">g</a> <a id="1783" href="A201801.LPTTDerivations.html#1783" class="Bound">n</a><a id="1784" class="Symbol">}</a> <a id="1786" class="Symbol">→</a> <a id="1788" href="A201801.LPTTAsserts.html#534" class="Datatype">Asserts</a> <a id="1796" href="A201801.LPTTDerivations.html#1779" class="Bound">d</a> <a id="1798" class="Symbol">→</a> <a id="1800" href="A201801.S4TTTerms.html#580" class="Function">Terms</a> <a id="1806" href="A201801.LPTTDerivations.html#1779" class="Bound">d</a> <a id="1808" href="A201801.LPTTDerivations.html#1781" class="Bound">g</a> <a id="1810" href="A201801.LPTTDerivations.html#1783" class="Bound">n</a> <a id="1812" class="Symbol">→</a> <a id="1814" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="1820" href="A201801.LPTTDerivations.html#1779" class="Bound">d</a> <a id="1822" href="A201801.LPTTDerivations.html#1783" class="Bound">n</a> <a id="1824" class="Symbol">→</a> <a id="1826" href="A201801.LPTTTypes.html#662" class="Function">Types</a> <a id="1832" href="A201801.LPTTDerivations.html#1779" class="Bound">d</a> <a id="1834" href="A201801.LPTTDerivations.html#1781" class="Bound">g</a> <a id="1836" class="Symbol">→</a> <a id="1838" class="PrimitiveType">Set</a>
<a id="1842" href="A201801.LPTTDerivations.html#1842" class="Bound">Δ</a> <a id="1844" href="A201801.LPTTDerivations.html#1757" class="Function Operator">⊢</a> <a id="1846" href="A201801.LPTTDerivations.html#1846" class="Bound">τ</a> <a id="1848" href="A201801.LPTTDerivations.html#1757" class="Function Operator">⦂</a> <a id="1850" href="A201801.LPTTDerivations.html#1850" class="Bound">Ξ</a> <a id="1852" href="A201801.LPTTDerivations.html#1757" class="Function Operator">allvalid[</a> <a id="1862" href="A201801.LPTTDerivations.html#1862" class="Bound">Γ</a> <a id="1864" href="A201801.LPTTDerivations.html#1757" class="Function Operator">]</a> <a id="1866" class="Symbol">=</a> <a id="1868" href="A201801.AllVec.html#172" class="Datatype">All</a> <a id="1872" class="Symbol">(\</a> <a id="1875" class="Symbol">{</a> <a id="1877" class="Symbol">(</a><a id="1878" href="A201801.LPTTDerivations.html#1878" class="Bound">M</a> <a id="1880" href="A201801.Prelude.html#4622" class="InductiveConstructor Operator">,</a> <a id="1882" href="A201801.LPTTDerivations.html#1882" class="Bound">A</a><a id="1883" class="Symbol">)</a> <a id="1885" class="Symbol">→</a> <a id="1887" href="A201801.LPTTDerivations.html#1842" class="Bound">Δ</a> <a id="1889" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⊢</a> <a id="1891" href="A201801.LPTTDerivations.html#1878" class="Bound">M</a> <a id="1893" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">⦂</a> <a id="1895" href="A201801.LPTTDerivations.html#1882" class="Bound">A</a> <a id="1897" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">valid[</a> <a id="1904" href="A201801.LPTTDerivations.html#1862" class="Bound">Γ</a> <a id="1906" href="A201801.LPTTDerivations.html#477" class="Datatype Operator">]</a> <a id="1908" class="Symbol">})</a> <a id="1911" class="Symbol">(</a><a id="1912" href="A201801.Vec.html#3269" class="Function">zip</a> <a id="1916" href="A201801.LPTTDerivations.html#1846" class="Bound">τ</a> <a id="1918" href="A201801.LPTTDerivations.html#1850" class="Bound">Ξ</a><a id="1919" class="Symbol">)</a>


<a id="1923" class="Comment">--------------------------------------------------------------------------------</a>


<a id="2006" class="Comment">-- ren : ∀ {d g g′ e M A} → {Δ : Asserts d} {Γ : Types g} {Γ′ : Types g′}</a>
<a id="2080" class="Comment">--                        → Γ′ ⊇⟨ e ⟩ Γ → Δ ⊢ M ⦂ A valid[ Γ ]</a>
<a id="2143" class="Comment">--                        → Δ ⊢ REN e M ⦂ A valid[ Γ′ ]</a>
<a id="2199" class="Comment">-- ren η (var i)      = var (ren∋ η i)</a>
<a id="2238" class="Comment">-- ren η (lam 𝒟)      = lam (ren (keep η) 𝒟)</a>
<a id="2283" class="Comment">-- ren η (app 𝒟 ℰ)    = app (ren η 𝒟) (ren η ℰ)</a>
<a id="2331" class="Comment">-- ren η (mvar i)     = mvar i</a>
<a id="2362" class="Comment">-- ren η (box 𝒟)      = box 𝒟</a>
<a id="2392" class="Comment">-- ren η (letbox 𝒟 ℰ) = letbox (ren η 𝒟) (ren η ℰ)</a>


<a id="2445" class="Comment">-- rens : ∀ {d g g′ e n} → {Δ : Asserts d} {Γ : Types g} {Γ′ : Types g′}</a>
<a id="2518" class="Comment">--                          {τ : Terms d g n} {Ξ : Types n}</a>
<a id="2578" class="Comment">--                       → Γ′ ⊇⟨ e ⟩ Γ → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="2643" class="Comment">--                       → Δ ⊢ RENS e τ ⦂ Ξ allvalid[ Γ′ ]</a>
<a id="2702" class="Comment">-- rens {τ = ∙}     {∙}     η ∙       = ∙</a>
<a id="2744" class="Comment">-- rens {τ = τ , M} {Ξ , A} η (ξ , 𝒟) = rens η ξ , ren η 𝒟</a>


<a id="2805" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="2891" class="Comment">-- mren : ∀ {d d′ g e M A} → {Δ : Asserts d} {Δ′ : Asserts d′} {Γ : Types g}</a>
<a id="2968" class="Comment">--                         → Δ′ ⊇⟨ e ⟩ Δ → Δ ⊢ M ⦂ A valid[ Γ ]</a>
<a id="3032" class="Comment">--                         → Δ′ ⊢ MREN e M ⦂ A valid[ Γ ]</a>
<a id="3090" class="Comment">-- mren η (var i)      = var i</a>
<a id="3121" class="Comment">-- mren η (lam 𝒟)      = lam (mren η 𝒟)</a>
<a id="3161" class="Comment">-- mren η (app 𝒟 ℰ)    = app (mren η 𝒟) (mren η ℰ)</a>
<a id="3212" class="Comment">-- mren η (mvar i)     = mvar (ren∋ η i)</a>
<a id="3253" class="Comment">-- mren η (box 𝒟)      = box (mren η 𝒟)</a>
<a id="3293" class="Comment">-- mren η (letbox 𝒟 ℰ) = letbox (mren η 𝒟) (mren (keep η) ℰ)</a>


<a id="3356" class="Comment">-- mrens : ∀ {d d′ g e n} → {Δ : Asserts d} {Δ′ : Asserts d′} {Γ : Types g}</a>
<a id="3432" class="Comment">--                           {τ : Terms d g n} {Ξ : Types n}</a>
<a id="3493" class="Comment">--                        → Δ′ ⊇⟨ e ⟩ Δ → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="3559" class="Comment">--                        → Δ′ ⊢ MRENS e τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="3620" class="Comment">-- mrens {τ = ∙}     {∙}     η ∙       = ∙</a>
<a id="3663" class="Comment">-- mrens {τ = τ , M} {Ξ , A} η (ξ , 𝒟) = mrens η ξ , mren η 𝒟</a>


<a id="3727" class="Comment">-- mrens* : ∀ {d d′ e n} → {Δ : Asserts d} {Δ′ : Asserts d′}</a>
<a id="3788" class="Comment">--                          {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="3849" class="Comment">--                       → Δ′ ⊇⟨ e ⟩ Δ → Δ ⊢ τ ⦂ Ξ allvalid*</a>
<a id="3910" class="Comment">--                       → Δ′ ⊢ MRENS* e τ ⦂ Ξ allvalid*</a>
<a id="3967" class="Comment">-- mrens* {τ = ∙}     {∙}     η ∙       = ∙</a>
<a id="4011" class="Comment">-- mrens* {τ = τ , M} {Ξ , A} η (ξ , 𝒟) = mrens* η ξ , mren η 𝒟</a>


<a id="4077" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="4163" class="Comment">-- wk : ∀ {B d g M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="4217" class="Comment">--                    → Δ ⊢ M ⦂ A valid[ Γ ]</a>
<a id="4262" class="Comment">--                    → Δ ⊢ WK M ⦂ A valid[ Γ , B ]</a>
<a id="4314" class="Comment">-- wk 𝒟 = ren (drop id⊇) 𝒟</a>


<a id="4343" class="Comment">-- wks : ∀ {A d g n} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="4396" class="Comment">--                      {τ : Terms d g n} {Ξ : Types n}</a>
<a id="4452" class="Comment">--                   → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="4499" class="Comment">--                   → Δ ⊢ WKS τ ⦂ Ξ allvalid[ Γ , A ]</a>
<a id="4554" class="Comment">-- wks ξ = rens (drop id⊇) ξ</a>


<a id="4585" class="Comment">-- vz : ∀ {d g A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="4635" class="Comment">--                → Δ ⊢ VZ ⦂ A valid[ Γ , A ]</a>
<a id="4681" class="Comment">-- vz = var zero</a>


<a id="4700" class="Comment">-- lifts : ∀ {A d g n} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="4755" class="Comment">--                        {τ : Terms d g n} {Ξ : Types n}</a>
<a id="4813" class="Comment">--                     → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="4862" class="Comment">--                     → Δ ⊢ LIFTS τ ⦂ Ξ , A allvalid[ Γ , A ]</a>
<a id="4925" class="Comment">-- lifts ξ = wks ξ , vz</a>


<a id="4951" class="Comment">-- vars : ∀ {d g g′ e} → {Δ : Asserts d} {Γ : Types g} {Γ′ : Types g′}</a>
<a id="5022" class="Comment">--                     → Γ′ ⊇⟨ e ⟩ Γ</a>
<a id="5059" class="Comment">--                     → Δ ⊢ VARS e ⦂ Γ allvalid[ Γ′ ]</a>
<a id="5114" class="Comment">-- vars done     = ∙</a>
<a id="5135" class="Comment">-- vars (drop η) = wks (vars η)</a>
<a id="5167" class="Comment">-- vars (keep η) = lifts (vars η)</a>


<a id="5203" class="Comment">-- ids : ∀ {d g} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="5252" class="Comment">--               → Δ ⊢ IDS ⦂ Γ allvalid[ Γ ]</a>
<a id="5297" class="Comment">-- ids = vars id⊇</a>


<a id="5317" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="5403" class="Comment">-- mwk : ∀ {B d g M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="5458" class="Comment">--                     → Δ ⊢ M ⦂ A valid[ Γ ]</a>
<a id="5504" class="Comment">--                     → Δ , ⟪⊫ B ⟫ ⊢ MWK M ⦂ A valid[ Γ ]</a>
<a id="5563" class="Comment">-- mwk 𝒟 = mren (drop id⊇) 𝒟</a>


<a id="5594" class="Comment">-- mwks : ∀ {A d g n} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="5648" class="Comment">--                       {τ : Terms d g n} {Ξ : Types n}</a>
<a id="5705" class="Comment">--                    → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="5753" class="Comment">--                    → Δ , ⟪⊫ A ⟫ ⊢ MWKS τ ⦂ Ξ allvalid[ Γ ]</a>
<a id="5815" class="Comment">-- mwks ξ = mrens (drop id⊇) ξ</a>


<a id="5848" class="Comment">-- mwks* : ∀ {A d n} → {Δ : Asserts d}</a>
<a id="5887" class="Comment">--                      {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="5944" class="Comment">--                   → Δ ⊢ τ ⦂ Ξ allvalid*</a>
<a id="5987" class="Comment">--                   → Δ , ⟪⊫ A ⟫ ⊢ MWKS* τ ⦂ Ξ allvalid*</a>
<a id="6045" class="Comment">-- mwks* ξ = mrens* (drop id⊇) ξ</a>


<a id="6080" class="Comment">-- mvz : ∀ {d g A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="6131" class="Comment">--                 → Δ , ⟪⊫ A ⟫ ⊢ MVZ ⦂ A valid[ Γ ]</a>
<a id="6184" class="Comment">-- mvz = mvar zero</a>


<a id="6205" class="Comment">-- mlifts* : ∀ {A d n} → {Δ : Asserts d}</a>
<a id="6246" class="Comment">--                        {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="6305" class="Comment">--                     → Δ ⊢ τ ⦂ Ξ allvalid*</a>
<a id="6350" class="Comment">--                     → Δ , ⟪⊫ A ⟫ ⊢ MLIFTS* τ ⦂ Ξ , ⟪⊫ A ⟫ allvalid*</a>
<a id="6421" class="Comment">-- mlifts* ξ = mwks* ξ , mvz</a>


<a id="6452" class="Comment">-- mvars* : ∀ {d d′ e} → {Δ : Asserts d} {Δ′ : Asserts d′}</a>
<a id="6511" class="Comment">--                     → Δ′ ⊇⟨ e ⟩ Δ</a>
<a id="6548" class="Comment">--                     → Δ′ ⊢ MVARS* e ⦂ Δ allvalid*</a>
<a id="6601" class="Comment">-- mvars* done     = ∙</a>
<a id="6624" class="Comment">-- mvars* (drop η) = mwks* (mvars* η)</a>
<a id="6662" class="Comment">-- mvars* (keep η) = mlifts* (mvars* η)</a>


<a id="6704" class="Comment">-- mids* : ∀ {d} → {Δ : Asserts d}</a>
<a id="6739" class="Comment">--               → Δ ⊢ MIDS* ⦂ Δ allvalid*</a>
<a id="6782" class="Comment">-- mids* = mvars* id⊇</a>


<a id="6806" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="6892" class="Comment">-- sub : ∀ {d g n M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="6947" class="Comment">--                        {τ : Terms d g n} {Ξ : Types n}</a>
<a id="7005" class="Comment">--                     → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ] → Δ ⊢ M ⦂ A valid[ Ξ ]</a>
<a id="7077" class="Comment">--                     → Δ ⊢ SUB τ M ⦂ A valid[ Γ ]</a>
<a id="7129" class="Comment">-- sub ξ (var i)      = get ξ (zip∋₂ i)</a>
<a id="7169" class="Comment">-- sub ξ (lam 𝒟)      = lam (sub (lifts ξ) 𝒟)</a>
<a id="7215" class="Comment">-- sub ξ (app 𝒟 ℰ)    = app (sub ξ 𝒟) (sub ξ ℰ)</a>
<a id="7263" class="Comment">-- sub ξ (mvar i)     = mvar i</a>
<a id="7294" class="Comment">-- sub ξ (box 𝒟)      = box 𝒟</a>
<a id="7324" class="Comment">-- sub ξ (letbox 𝒟 ℰ) = letbox (sub ξ 𝒟) (sub (mwks ξ) ℰ)</a>


<a id="7384" class="Comment">-- subs : ∀ {d g n m} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="7438" class="Comment">--                       {τ : Terms d g n} {Ξ : Types n}</a>
<a id="7495" class="Comment">--                       {υ : Terms d n m} {Ψ : Types m}</a>
<a id="7552" class="Comment">--                    → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ] → Δ ⊢ υ ⦂ Ψ allvalid[ Ξ ]</a>
<a id="7626" class="Comment">--                    → Δ ⊢ SUBS τ υ ⦂ Ψ allvalid[ Γ ]</a>
<a id="7681" class="Comment">-- subs {υ = ∙}     {∙}     ξ ∙       = ∙</a>
<a id="7723" class="Comment">-- subs {υ = υ , M} {Ψ , A} ξ (ψ , 𝒟) = subs ξ ψ , sub ξ 𝒟</a>


<a id="7784" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="7870" class="Comment">-- msub : ∀ {d g n M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="7926" class="Comment">--                         {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="7986" class="Comment">--                      → Δ ⊢ τ ⦂ Ξ allvalid* → Ξ ⊢ M ⦂ A valid[ Γ ]</a>
<a id="8055" class="Comment">--                      → Δ ⊢ MSUB τ M ⦂ A valid[ Γ ]</a>
<a id="8109" class="Comment">-- msub ξ (var i)      = var i</a>
<a id="8140" class="Comment">-- msub ξ (lam 𝒟)      = lam (msub ξ 𝒟)</a>
<a id="8180" class="Comment">-- msub ξ (app 𝒟 ℰ)    = app (msub ξ 𝒟) (msub ξ ℰ)</a>
<a id="8231" class="Comment">-- msub ξ (mvar i)     = sub ∙ (get ξ (zip∋₂ i))</a>
<a id="8280" class="Comment">-- msub ξ (box 𝒟)      = box (msub ξ 𝒟)</a>
<a id="8320" class="Comment">-- msub ξ (letbox 𝒟 ℰ) = letbox (msub ξ 𝒟) (msub (mlifts* ξ) ℰ)</a>


<a id="8386" class="Comment">-- msubs : ∀ {d g n m} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="8441" class="Comment">--                        {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="8500" class="Comment">--                        {υ : Terms n g m} {Ψ : Types m}</a>
<a id="8558" class="Comment">--                     → Δ ⊢ τ ⦂ Ξ allvalid* → Ξ ⊢ υ ⦂ Ψ allvalid[ Γ ]</a>
<a id="8629" class="Comment">--                     → Δ ⊢ MSUBS τ υ ⦂ Ψ allvalid[ Γ ]</a>
<a id="8686" class="Comment">-- msubs {υ = ∙}     {∙}     ξ ∙       = ∙</a>
<a id="8729" class="Comment">-- msubs {υ = υ , M} {Ψ , A} ξ (ψ , 𝒟) = msubs ξ ψ , msub ξ 𝒟</a>


<a id="8793" class="Comment">-- msubs* : ∀ {d n m} → {Δ : Asserts d}</a>
<a id="8833" class="Comment">--                       {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="8891" class="Comment">--                       {υ : Terms* n m} {Ψ : Asserts m}</a>
<a id="8949" class="Comment">--                    → Δ ⊢ τ ⦂ Ξ allvalid* → Ξ ⊢ υ ⦂ Ψ allvalid*</a>
<a id="9015" class="Comment">--                    → Δ ⊢ MSUBS* τ υ ⦂ Ψ allvalid*</a>
<a id="9068" class="Comment">-- msubs* {υ = ∙}     {∙}           ξ ∙       = ∙</a>
<a id="9118" class="Comment">-- msubs* {υ = υ , M} {Ψ , ⟪⊫ A ⟫} ξ (ψ , 𝒟) = msubs* ξ ψ , msub ξ 𝒟</a>


<a id="9189" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="9275" class="Comment">-- unlam : ∀ {d g M A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="9332" class="Comment">--                       → Δ ⊢ M ⦂ A ⊃ B valid[ Γ ]</a>
<a id="9384" class="Comment">--                       → Δ ⊢ UNLAM M ⦂ B valid[ Γ , A ]</a>
<a id="9442" class="Comment">-- unlam 𝒟 = app (wk 𝒟) vz</a>


<a id="9471" class="Comment">-- cut : ∀ {d g M N A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="9528" class="Comment">--                       → Δ ⊢ M ⦂ A valid[ Γ ] → Δ ⊢ N ⦂ B valid[ Γ , A ]</a>
<a id="9603" class="Comment">--                       → Δ ⊢ CUT M N ⦂ B valid[ Γ ]</a>
<a id="9657" class="Comment">-- cut 𝒟 ℰ = sub (ids , 𝒟) ℰ</a>


<a id="9688" class="Comment">-- pseudocut : ∀ {d g M N A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="9751" class="Comment">--                             → Δ ⊢ M ⦂ A valid[ Γ ] → Δ ⊢ N ⦂ B valid[ Γ , A ]</a>
<a id="9832" class="Comment">--                             → Δ ⊢ PSEUDOCUT M N ⦂ B valid[ Γ ]</a>
<a id="9898" class="Comment">-- pseudocut 𝒟 ℰ = app (lam ℰ) 𝒟</a>


<a id="9933" class="Comment">-- pseudosub : ∀ {d g n M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="9994" class="Comment">--                              {τ : Terms d g n} {Ξ : Types n}</a>
<a id="10058" class="Comment">--                           → Δ ⊢ τ ⦂ Ξ allvalid[ Γ ] → Δ ⊢ M ⦂ A valid[ Ξ ]</a>
<a id="10136" class="Comment">--                           → Δ ⊢ PSEUDOSUB τ M ⦂ A valid[ Γ ]</a>
<a id="10200" class="Comment">-- pseudosub {τ = ∙}     {∙}     ∙       𝒟 = ren bot⊇ 𝒟</a>
<a id="10256" class="Comment">-- pseudosub {τ = τ , M} {Ξ , B} (ξ , 𝒞) 𝒟 = app (pseudosub ξ (lam 𝒟)) 𝒞</a>


<a id="10331" class="Comment">-- exch : ∀ {d g M A B C} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="10389" class="Comment">--                        → Δ ⊢ M ⦂ C valid[ Γ , A , B ]</a>
<a id="10446" class="Comment">--                        → Δ ⊢ EXCH M ⦂ C valid[ Γ , B , A ]</a>
<a id="10508" class="Comment">-- exch 𝒟 = app (app (wk (wk (lam (lam 𝒟)))) vz) (wk vz)</a>


<a id="10567" class="Comment">-- --------------------------------------------------------------------------------</a>


<a id="10653" class="Comment">-- vau : ∀ {d g M A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="10708" class="Comment">--                     → Δ , ⟪⊫ A ⟫ ⊢ M ⦂ B valid[ Γ ]</a>
<a id="10763" class="Comment">--                     → Δ ⊢ VAU M ⦂ B valid[ Γ , □ A ]</a>
<a id="10819" class="Comment">-- vau 𝒟 = letbox vz (wk 𝒟)</a>


<a id="10849" class="Comment">-- unvau : ∀ {d g M A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="10906" class="Comment">--                       → Δ ⊢ M ⦂ B valid[ Γ , □ A ]</a>
<a id="10960" class="Comment">--                       → Δ , ⟪⊫ A ⟫ ⊢ UNVAU M ⦂ B valid[ Γ ]</a>
<a id="11023" class="Comment">-- unvau 𝒟 = app (lam (mwk 𝒟)) (box mvz)</a>


<a id="11066" class="Comment">-- boxapp : ∀ {d g M N A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="11126" class="Comment">--                          → Δ ⊢ M ⦂ □ (A ⊃ B) valid[ Γ ] → Δ ⊢ N ⦂ □ A valid[ Γ ]</a>
<a id="11210" class="Comment">--                          → Δ ⊢ BOXAPP M N ⦂ □ B valid[ Γ ]</a>
<a id="11272" class="Comment">-- boxapp 𝒟 ℰ = letbox 𝒟 (letbox (mwk ℰ) (box (app (mwk mvz) mvz)))</a>


<a id="11342" class="Comment">-- unbox : ∀ {d g M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="11397" class="Comment">--                     → Δ ⊢ M ⦂ □ A valid[ Γ ]</a>
<a id="11445" class="Comment">--                     → Δ ⊢ UNBOX M ⦂ A valid[ Γ ]</a>
<a id="11497" class="Comment">-- unbox 𝒟 = letbox 𝒟 mvz</a>


<a id="11525" class="Comment">-- -- NOTE: Local completeness of □</a>

<a id="11562" class="Comment">-- rebox : ∀ {d g M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="11617" class="Comment">--                     → Δ ⊢ M ⦂ □ A valid[ Γ ]</a>
<a id="11665" class="Comment">--                     → Δ ⊢ REBOX M ⦂ □ A valid[ Γ ]</a>
<a id="11719" class="Comment">-- rebox 𝒟 = letbox 𝒟 (box mvz)</a>


<a id="11753" class="Comment">-- dupbox : ∀ {d g M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="11809" class="Comment">--                      → Δ ⊢ M ⦂ □ A valid[ Γ ]</a>
<a id="11858" class="Comment">--                      → Δ ⊢ DUPBOX M ⦂ □ □ A valid[ Γ ]</a>
<a id="11916" class="Comment">-- dupbox 𝒟 = letbox 𝒟 (box (box mvz))</a>


<a id="11957" class="Comment">-- mcut : ∀ {d g M N A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="12015" class="Comment">--                        → Δ ⊢ M ⦂ A valid[ ∙ ] → Δ , ⟪⊫ A ⟫ ⊢ N ⦂ B valid[ Γ ]</a>
<a id="12096" class="Comment">--                        → Δ ⊢ MCUT M N ⦂ B valid[ Γ ]</a>
<a id="12152" class="Comment">-- mcut 𝒟 ℰ = msub (mids* , 𝒟) ℰ</a>


<a id="12187" class="Comment">-- -- NOTE: Local soundness of □</a>

<a id="12221" class="Comment">-- pseudomcut : ∀ {d g M N A B} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="12285" class="Comment">--                              → Δ ⊢ M ⦂ A valid[ ∙ ] → Δ , ⟪⊫ A ⟫ ⊢ N ⦂ B valid[ Γ ]</a>
<a id="12372" class="Comment">--                              → Δ ⊢ PSEUDOMCUT M N ⦂ B valid[ Γ ]</a>
<a id="12440" class="Comment">-- pseudomcut 𝒟 ℰ = letbox (box 𝒟) ℰ</a>


<a id="12479" class="Comment">-- pseudomsub : ∀ {d g n M A} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="12541" class="Comment">--                               {τ : Terms* d n} {Ξ : Asserts n}</a>
<a id="12607" class="Comment">--                            → Δ ⊢ τ ⦂ Ξ allvalid* → Ξ ⊢ M ⦂ A valid[ Γ ]</a>
<a id="12682" class="Comment">--                            → Δ ⊢ PSEUDOMSUB τ M ⦂ A valid[ Γ ]</a>
<a id="12748" class="Comment">-- pseudomsub {τ = ∙}     {∙}           ∙       𝒟 = mren bot⊇ 𝒟</a>
<a id="12812" class="Comment">-- pseudomsub {τ = τ , M} {Ξ , ⟪⊫ A ⟫} (ξ , 𝒞) 𝒟 = app (pseudomsub ξ (lam (vau 𝒟))) (box 𝒞)</a>


<a id="12906" class="Comment">-- mexch : ∀ {d g M A B C} → {Δ : Asserts d} {Γ : Types g}</a>
<a id="12965" class="Comment">--                         → Δ , ⟪⊫ A ⟫ , ⟪⊫ B ⟫ ⊢ M ⦂ C valid[ Γ ]</a>
<a id="13033" class="Comment">--                         → Δ , ⟪⊫ B ⟫ , ⟪⊫ A ⟫ ⊢ MEXCH M ⦂ C valid[ Γ ]</a>
<a id="13107" class="Comment">-- mexch 𝒟 = unvau (unvau (exch (vau (vau 𝒟))))</a>


<a id="13157" class="Comment">-- --------------------------------------------------------------------------------</a>
</pre></body></html>